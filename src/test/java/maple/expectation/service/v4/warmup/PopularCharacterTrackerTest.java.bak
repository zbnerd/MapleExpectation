package maple.expectation.service.v4.warmup;

import static org.assertj.core.api.Assertions.assertThat;

import io.micrometer.core.instrument.MeterRegistry;
import java.time.LocalDate;
import java.util.List;
import maple.expectation.global.executor.LogicExecutor;
import maple.expectation.support.IntegrationTestSupport;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.TestPropertySource;

/**
 * PopularCharacterTracker 통합 테스트 (#275 Auto Warmup)
 *
 * <p>Testcontainers로 실제 Redis를 사용하여 Sorted Set 동작을 검증합니다.
 */
@TestPropertySource(
    properties = {"scheduler.warmup.enabled=false", "scheduler.like-sync.enabled=false"})
class PopularCharacterTrackerTest extends IntegrationTestSupport {

  @Autowired private LogicExecutor executor;

  @Autowired private MeterRegistry meterRegistry;

  private RedissonClient redissonClient;
  private PopularCharacterTracker tracker;

  @BeforeEach
  void setUp() {
    Config config = new Config();
    config
        .useSingleServer()
        .setAddress("redis://" + REDIS.getHost() + ":" + REDIS.getMappedPort(6379));
    redissonClient = Redisson.create(config);

    tracker = new PopularCharacterTracker(redissonClient, executor, meterRegistry);

    // 테스트 전 데이터 초기화
    String todayKey = "popular:characters:" + LocalDate.now();
    redissonClient.getKeys().delete(todayKey);
  }

  @Test
  @DisplayName("호출 기록 시 Redis Sorted Set에 점수가 증가한다")
  void recordAccess_incrementsScore() {
    // given
    String userIgn = "테스트캐릭터";

    // when
    tracker.recordAccess(userIgn);
    tracker.recordAccess(userIgn);
    tracker.recordAccess(userIgn);

    // then
    int count = tracker.getAccessCount(LocalDate.now(), userIgn);
    assertThat(count).isEqualTo(3);
  }

  @Test
  @DisplayName("여러 캐릭터 호출 시 상위 N개를 호출 횟수 내림차순으로 반환한다")
  void getTopCharacters_returnsInDescendingOrder() {
    // given
    String popular = "인기캐릭터";
    String normal = "일반캐릭터";
    String rare = "희귀캐릭터";

    // popular: 10회, normal: 5회, rare: 1회
    for (int i = 0; i < 10; i++) tracker.recordAccess(popular);
    for (int i = 0; i < 5; i++) tracker.recordAccess(normal);
    tracker.recordAccess(rare);

    // when
    List<String> top = tracker.getTopCharacters(LocalDate.now(), 2);

    // then
    assertThat(top).hasSize(2);
    assertThat(top.get(0)).isEqualTo(popular); // 1위: 10회
    assertThat(top.get(1)).isEqualTo(normal); // 2위: 5회
  }

  @Test
  @DisplayName("유니크 캐릭터 수를 정확히 반환한다")
  void getTodayUniqueCount_returnsCorrectCount() {
    // given
    tracker.recordAccess("캐릭터1");
    tracker.recordAccess("캐릭터1");
    tracker.recordAccess("캐릭터2");
    tracker.recordAccess("캐릭터3");

    // when
    int uniqueCount = tracker.getTodayUniqueCount();

    // then
    assertThat(uniqueCount).isEqualTo(3); // 3명의 유니크 캐릭터
  }

  @Test
  @DisplayName("데이터가 없으면 빈 리스트를 반환한다")
  void getTopCharacters_returnsEmptyWhenNoData() {
    // when
    List<String> top = tracker.getYesterdayTopCharacters(10);

    // then
    assertThat(top).isEmpty();
  }
}
