package maple.expectation.chaos.core;

import static org.assertj.core.api.Assertions.assertThat;

import java.time.Duration;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import maple.expectation.support.AbstractContainerBaseTest;
import org.awaitility.Awaitility;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.cache.CacheManager;
import org.springframework.data.redis.core.StringRedisTemplate;

/**
 * Scenario 01: Redisê°€ ì£½ì—ˆì„ ê²½ìš°
 *
 * <h4>5-Agent Council</h4>
 *
 * <ul>
 *   <li>ğŸ”´ Red (SRE): ì¥ì•  ì£¼ì… - Toxiproxyë¡œ Redis ì»¤ë„¥ì…˜ ì°¨ë‹¨
 *   <li>ğŸŸ£ Purple (Auditor): ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦ - ìºì‹œ ì¼ê´€ì„± í™•ì¸
 *   <li>ğŸ”µ Blue (Architect): íë¦„ ê²€ì¦ - TieredCache L1 Fallback
 *   <li>ğŸŸ¢ Green (Performance): ë©”íŠ¸ë¦­ ê²€ì¦ - Circuit Breaker ìƒíƒœ
 *   <li>ğŸŸ¡ Yellow (QA Master): í…ŒìŠ¤íŠ¸ ì „ëµ - Graceful Degradation ê²€ì¦
 * </ul>
 *
 * <h4>ê²€ì¦ í¬ì¸íŠ¸</h4>
 *
 * <ol>
 *   <li>Redis ì¥ì•  ì‹œ TieredCacheê°€ L1(Caffeine)ë§Œìœ¼ë¡œ ë™ì‘
 *   <li>ResilientLockStrategyê°€ MySQL Named Lockìœ¼ë¡œ Fallback
 *   <li>Circuit Breaker 'redisLock'ì´ OPEN ìƒíƒœë¡œ ì „ì´
 *   <li>ì„œë¹„ìŠ¤ ê°€ìš©ì„± ìœ ì§€ (5xx ì—ëŸ¬ ì—†ìŒ)
 * </ol>
 *
 * <h4>CS ì›ë¦¬</h4>
 *
 * <ul>
 *   <li>CAP ì •ë¦¬: Partition ë°œìƒ ì‹œ Availability ìš°ì„ 
 *   <li>Graceful Degradation: ë¶€ë¶„ ì¥ì•  ì‹œ ê¸°ëŠ¥ ì €í•˜ë¡œ ì„œë¹„ìŠ¤ ìœ ì§€
 *   <li>Circuit Breaker íŒ¨í„´: ì¥ì•  ê²©ë¦¬ ë° ë¹ ë¥¸ ì‹¤íŒ¨
 * </ul>
 *
 * @see maple.expectation.global.cache.TieredCache
 * @see maple.expectation.global.lock.ResilientLockStrategy
 */
@Tag("chaos")
@SpringBootTest
@DisplayName("Scenario 01: Redis Death - Graceful Degradation ê²€ì¦")
class RedisDeathChaosTest extends AbstractContainerBaseTest {

  @Autowired private CacheManager cacheManager;

  @Autowired(required = false)
  private StringRedisTemplate redisTemplate;

  private static final String TEST_CACHE_NAME = "testCache";
  private static final String TEST_KEY = "chaos-test-key";
  private static final String TEST_VALUE = "chaos-test-value";

  @BeforeEach
  void setUp() {
    // í…ŒìŠ¤íŠ¸ ì „ Redis ì—°ê²° ì •ìƒ í™•ì¸
    recoverMaster();
  }

  @AfterEach
  void tearDown() {
    // í…ŒìŠ¤íŠ¸ í›„ Redis ë³µêµ¬
    recoverMaster();
  }

  /**
   * ğŸŸ¡ Yellow's Test 1: Redis ì¥ì•  ì‹œ L1 ìºì‹œë§Œìœ¼ë¡œ ì„œë¹„ìŠ¤ ê°€ìš©ì„± ìœ ì§€
   *
   * <p><b>ì‹œë‚˜ë¦¬ì˜¤</b>:
   *
   * <ol>
   *   <li>ì •ìƒ ìƒíƒœì—ì„œ ìºì‹œì— ë°ì´í„° ì €ì¥ (L1 + L2)
   *   <li>Redis(L2) ì¥ì•  ì£¼ì…
   *   <li>ìºì‹œ ì¡°íšŒ â†’ L1ì—ì„œ ë°ì´í„° ë°˜í™˜
   * </ol>
   *
   * <p><b>ì˜ˆìƒ ë¡œê·¸</b>:
   *
   * <pre>
   * WARN  [xxx] TieredCache - L2 put failed, skipping L1 for consistency
   * </pre>
   */
  @Test
  @DisplayName("Redis ì¥ì•  ì‹œ L1 ìºì‹œ Fallbackìœ¼ë¡œ ì„œë¹„ìŠ¤ ê°€ìš©ì„± ìœ ì§€")
  void shouldFallbackToL1Cache_whenRedisDown() {
    // Given: ì •ìƒ ìƒíƒœì—ì„œ ìºì‹œì— ë°ì´í„° ì €ì¥
    var cache = cacheManager.getCache(TEST_CACHE_NAME);
    assertThat(cache).isNotNull();

    // Redis ì •ìƒ ìƒíƒœ í™•ì¸
    assertThat(isRedisConnected()).isTrue();

    cache.put(TEST_KEY, TEST_VALUE);

    // L1 ìºì‹œì— ë°ì´í„° ì¡´ì¬ í™•ì¸
    var cachedValue = cache.get(TEST_KEY, String.class);
    assertThat(cachedValue).isEqualTo(TEST_VALUE);

    // When: Redis ì¥ì•  ì£¼ì… (Toxiproxy)
    failMaster();

    // Then: L1 ìºì‹œì—ì„œ ë°ì´í„° ì¡°íšŒ ê°€ëŠ¥
    Awaitility.await()
        .atMost(Duration.ofSeconds(5))
        .untilAsserted(
            () -> {
              String result = cache.get(TEST_KEY, String.class);
              assertThat(result).as("Redis ì¥ì•  ì‹œì—ë„ L1 ìºì‹œì—ì„œ ë°ì´í„° ì¡°íšŒ ê°€ëŠ¥í•´ì•¼ í•¨").isEqualTo(TEST_VALUE);
            });
  }

  /**
   * ğŸŸ¡ Yellow's Test 2: Redis ì¥ì•  ì‹œ ìƒˆ ë°ì´í„° ì €ì¥ì€ L1ì—ë§Œ ì €ì¥
   *
   * <p><b>ì‹œë‚˜ë¦¬ì˜¤</b>:
   *
   * <ol>
   *   <li>Redis(L2) ì¥ì•  ì£¼ì…
   *   <li>ìƒˆ ë°ì´í„° ìºì‹œ ì €ì¥ ì‹œë„
   *   <li>L2 ì €ì¥ ì‹¤íŒ¨ â†’ L1 ìŠ¤í‚µ (ì¼ê´€ì„± ë³´ì¥)
   * </ol>
   *
   * <p><b>ì˜ˆìƒ ë™ì‘</b>: L2 ì¥ì•  ì‹œ L1ë„ ìŠ¤í‚µí•˜ì—¬ ê³„ì¸µ ê°„ ë¶ˆì¼ì¹˜ ë°©ì§€
   */
  @Test
  @DisplayName("Redis ì¥ì•  ì‹œ ìºì‹œ ì €ì¥ì€ L2 ì‹¤íŒ¨ë¡œ ì¸í•´ ìŠ¤í‚µë¨")
  void shouldSkipL1Put_whenL2PutFails() {
    // Given: Redis ì¥ì•  ìƒíƒœ
    failMaster();

    var cache = cacheManager.getCache(TEST_CACHE_NAME);
    assertThat(cache).isNotNull();

    String newKey = "new-key-" + System.currentTimeMillis();
    String newValue = "new-value";

    // When: ìƒˆ ë°ì´í„° ì €ì¥ ì‹œë„
    cache.put(newKey, newValue);

    // Then: L2 ì¥ì• ë¡œ ì¸í•´ ë°ì´í„°ê°€ ìºì‹œë˜ì§€ ì•ŠìŒ (ì¼ê´€ì„± ìš°ì„  ì •ì±…)
    // ì°¸ê³ : TieredCacheëŠ” L2 ì‹¤íŒ¨ ì‹œ L1ë„ ìŠ¤í‚µ
    Awaitility.await()
        .atMost(Duration.ofSeconds(5))
        .untilAsserted(
            () -> {
              // ì¥ì•  ìƒíƒœì—ì„œ ìƒˆ í‚¤ ì¡°íšŒ - null ë°˜í™˜ ì˜ˆìƒ
              // (L2 ì‹¤íŒ¨ â†’ L1 ìŠ¤í‚µ ì •ì±…ì— ë”°ë¼ ë°ì´í„° ë¯¸ì €ì¥)
              // Note: êµ¬í˜„ì— ë”°ë¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ
            });
  }

  /**
   * ğŸŸ¡ Yellow's Test 3: ë™ì‹œ ìš”ì²­ ì‹œ Redis ì¥ì• ì—ë„ ì„œë¹„ìŠ¤ ê°€ìš©ì„± ìœ ì§€
   *
   * <p><b>ì‹œë‚˜ë¦¬ì˜¤</b>:
   *
   * <ol>
   *   <li>Redis ì¥ì•  ì£¼ì…
   *   <li>100ê°œ ë™ì‹œ ìš”ì²­ ë°œìƒ
   *   <li>ëª¨ë“  ìš”ì²­ì´ ì˜ˆì™¸ ì—†ì´ ì™„ë£Œ
   * </ol>
   *
   * <p><b>ì„±ê³µ ê¸°ì¤€</b>: ì˜ˆì™¸ ë°œìƒ 0ê±´, ëª¨ë“  ìš”ì²­ ì •ìƒ ì™„ë£Œ
   */
  @Test
  @DisplayName("ë™ì‹œ ìš”ì²­ ì‹œ Redis ì¥ì• ì—ë„ ì„œë¹„ìŠ¤ ê°€ìš©ì„± ìœ ì§€")
  void shouldMaintainAvailability_underConcurrentLoad_whenRedisDown() throws InterruptedException {
    // Given
    int concurrentRequests = 100;
    AtomicInteger successCount = new AtomicInteger(0);
    AtomicInteger failureCount = new AtomicInteger(0);

    ExecutorService executor = Executors.newFixedThreadPool(10);
    CountDownLatch startLatch = new CountDownLatch(1);
    CountDownLatch endLatch = new CountDownLatch(concurrentRequests);

    var cache = cacheManager.getCache(TEST_CACHE_NAME);
    assertThat(cache).isNotNull();

    // Pre-warm: ì •ìƒ ìƒíƒœì—ì„œ ë°ì´í„° ì €ì¥
    cache.put(TEST_KEY, TEST_VALUE);

    // Redis ì¥ì•  ì£¼ì…
    failMaster();

    // When: ë™ì‹œ ìš”ì²­ ë°œìƒ
    for (int i = 0; i < concurrentRequests; i++) {
      executor.submit(
          () -> {
            try {
              startLatch.await();
              // ìºì‹œ ì¡°íšŒ ì‹œë„
              String result = cache.get(TEST_KEY, String.class);
              if (result != null) {
                successCount.incrementAndGet();
              }
            } catch (Exception e) {
              failureCount.incrementAndGet();
            } finally {
              endLatch.countDown();
            }
          });
    }

    startLatch.countDown();
    boolean completed = endLatch.await(30, TimeUnit.SECONDS);

    // Cleanup
    executor.shutdown();
    executor.awaitTermination(10, TimeUnit.SECONDS);

    // Then
    assertThat(completed).as("ëª¨ë“  ìš”ì²­ì´ 30ì´ˆ ë‚´ì— ì™„ë£Œë˜ì–´ì•¼ í•¨").isTrue();

    assertThat(failureCount.get()).as("Redis ì¥ì•  ì‹œì—ë„ ì˜ˆì™¸ ë°œìƒ ì—†ì–´ì•¼ í•¨ (Graceful Degradation)").isZero();

    // L1 ìºì‹œì— ë°ì´í„°ê°€ ìˆìœ¼ë¯€ë¡œ ì„±ê³µí•´ì•¼ í•¨
    assertThat(successCount.get()).as("L1 ìºì‹œì—ì„œ ë°ì´í„° ì¡°íšŒ ì„±ê³µ").isEqualTo(concurrentRequests);
  }

  /**
   * ğŸŸ¡ Yellow's Test 4: Redis ë³µêµ¬ í›„ ì •ìƒ ë™ì‘ í™•ì¸
   *
   * <p><b>ì‹œë‚˜ë¦¬ì˜¤</b>:
   *
   * <ol>
   *   <li>Redis ì¥ì•  ì£¼ì…
   *   <li>ì¥ì•  ìƒíƒœì—ì„œ ìºì‹œ ì¡°íšŒ (L1 fallback)
   *   <li>Redis ë³µêµ¬
   *   <li>ìƒˆ ë°ì´í„° ì €ì¥ â†’ L2ì—ë„ ì €ì¥ë¨
   * </ol>
   */
  @Test
  @DisplayName("Redis ë³µêµ¬ í›„ L2 ìºì‹œ ì •ìƒ ë™ì‘")
  void shouldResumeL2Operations_afterRedisRecovery() {
    // Given: ì¥ì•  ì£¼ì…
    failMaster();

    var cache = cacheManager.getCache(TEST_CACHE_NAME);
    assertThat(cache).isNotNull();

    // ì¥ì•  ìƒíƒœ í™•ì¸
    assertThat(isRedisConnected()).isFalse();

    // When: ë³µêµ¬
    recoverMaster();

    // Then: ë³µêµ¬ í›„ ì •ìƒ ë™ì‘
    Awaitility.await()
        .atMost(Duration.ofSeconds(10))
        .pollInterval(Duration.ofSeconds(1))
        .untilAsserted(
            () -> {
              assertThat(isRedisConnected()).as("Redis ë³µêµ¬ í›„ ì—°ê²° ê°€ëŠ¥í•´ì•¼ í•¨").isTrue();

              // ìƒˆ ë°ì´í„° ì €ì¥ ë° ì¡°íšŒ
              String recoveryKey = "recovery-key-" + System.currentTimeMillis();
              cache.put(recoveryKey, "recovery-value");

              String result = cache.get(recoveryKey, String.class);
              assertThat(result).isEqualTo("recovery-value");
            });
  }

  // ==================== Helper Methods ====================

  /** Redis ì—°ê²° ìƒíƒœ í™•ì¸ */
  private boolean isRedisConnected() {
    if (redisTemplate == null) {
      return false;
    }
    try {
      String pong = redisTemplate.getConnectionFactory().getConnection().ping();
      return "PONG".equalsIgnoreCase(pong);
    } catch (Exception e) {
      return false;
    }
  }
}
