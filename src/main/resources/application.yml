spring:
  threads:
    virtual:
      enabled: true
  application:
    name: maple-expectation
  profiles:
    active: local # [Safety Guard] 별도 설정 없으면 무조건 로컬 모드
  lifecycle:
    timeout-per-shutdown-phase: 50s # Graceful Shutdown 시 충분한 시간 확보 (Equipment 대기 20s + Redis sync + 여유)

  # 공통 드라이버 설정
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      register-mbeans: true # JMX를 통해 지표 노출 활성화
      connection-timeout: 3000      # 커넥션 획득 타임아웃 3초 (Red Agent P1 Fix)
      leak-detection-threshold: 60000  # 60초 이상 반납 안되면 누수 의심 로그
      # [P0-N07 Fix] MDL Freeze 방지 - 세션 lock_wait_timeout 설정
      # 단일 문장만 지원 (P1-GREEN-01), MDL에는 lock_wait_timeout이 효과적
      # Issue #225: lock_wait_timeout 10s → 8s (Timeout Hierarchy 정렬 - Redis timeout과 동일)
      connection-init-sql: "SET SESSION lock_wait_timeout = 8"

  # 공통 JPA 설정
  jpa:
    open-in-view: false
    properties:
      hibernate:
        jdbc:
          batch_size: 1000
        format_sql: false
        show_sql: false

management:
  endpoints:
    web:
      exposure:
        include: "health,info,metrics,prometheus,loggers"

  endpoint:
    health:
      show-details: always # 서킷 브레이커 상태를 상세히 보기 위해 필수
  health:
    circuitbreakers:
      enabled: true
  metrics:
    tags:
      application: ${spring.application.name} # 모든 메트릭에 앱 이름 태그 부여

resilience4j:
  circuitbreaker:
    circuit-breaker-aspect-order: 400
    configs:
      default:
        registerHealthIndicator: true
        slidingWindowSize: 10              # 최근 10번의 호출 기준
        failureRateThreshold: 50           # 실패율 50% 이상 시 Open
        waitDurationInOpenState: 10s       # Open 유지 시간
        permittedNumberOfCallsInHalfOpenState: 3
        ignoreExceptions:
          # 비즈니스 예외(404 등)는 실패로 카운트하지 않음
          - maple.expectation.global.error.exception.marker.CircuitBreakerIgnoreMarker
        recordExceptions:
          - maple.expectation.global.error.exception.marker.CircuitBreakerRecordMarker
    instances:
      nexonApi:
        baseConfig: default
        minimumNumberOfCalls: 10        # 최소 10번 호출 후 통계 산출 (Red Agent P1 Fix)
      likeSyncDb:  # Issue #48: Like Sync DB Batch Update 전용 Circuit Breaker
        slidingWindowSize: 5            # 최근 5번의 청크 처리 기준
        failureRateThreshold: 60        # 60% 실패율에서 Open
        waitDurationInOpenState: 30s    # Open 후 30초 대기 (DB 복구 시간 확보)
        minimumNumberOfCalls: 3         # 최소 3번 호출 후 통계 산출
        permittedNumberOfCallsInHalfOpenState: 2
        registerHealthIndicator: true
      redisLock:  # Redis 분산 락 전용 Circuit Breaker
        slidingWindowSize: 20              # 락 작업은 빈번하므로 더 많은 샘플 수집
        failureRateThreshold: 60           # 60% 실패율에서 Open (락 경합은 정상적일 수 있음)
        waitDurationInOpenState: 30s       # Open 후 30초 대기 (Redis 복구 시간 확보)
        minimumNumberOfCalls: 5            # 최소 5번 호출 후 통계 산출
        permittedNumberOfCallsInHalfOpenState: 3
        registerHealthIndicator: true
        recordExceptions:                  # 이 예외들이 발생하면 실패로 간주
          - org.redisson.client.RedisException
          - org.redisson.client.RedisTimeoutException
          - java.util.concurrent.TimeoutException
          - maple.expectation.global.error.exception.DistributedLockException

  retry:
    retry-aspect-order: 399 # Retry가 CircuitBreaker를 감싸도록 설정
    instances:
      nexonApi:
        maxAttempts: 3
        waitDuration: 500ms
        retryExceptions:
          - java.util.concurrent.TimeoutException
          - io.netty.handler.timeout.ReadTimeoutException  # Reactor Netty responseTimeout 발생 시
          - org.springframework.web.reactive.function.client.WebClientRequestException # 네트워크 단절 대응
          - java.net.UnknownHostException
          - maple.expectation.global.error.exception.ExternalServiceException  # Issue #202: 외부 서비스 장애 시 재시도
      nexonLockRetry:
        maxAttempts: 5             # 최대 5번 시도 (락 경합이 심할 때를 대비해 조금 넓넉히)
        waitDuration: 200ms        # 0.2초 간격으로 다시 시도
        retryExceptions:           # 이 예외가 발생했을 때만 재시도함
          - maple.expectation.global.error.exception.DistributedLockException

  timelimiter:
    timelimiter-aspect-order: 398 # TimeLimiter → Retry → CircuitBreaker 순서
    instances:
      nexonApi:
        # 상한 예산: maxAttempts*(connect+response) + (maxAttempts-1)*wait + margin
        # = 3*(3s+5s) + 2*0.5s + 3s = 24 + 1 + 3 = 28s (3회 재시도 최악 시나리오 상한 보장)
        timeoutDuration: 28s        # 전체 작업 타임아웃 (3회 재시도 상한 보장)
        cancelRunningFuture: true   # 타임아웃 시 실행 중인 Future 취소

logging:
  level:
    org.springframework.cache: INFO
    maple.expectation.aop.aspect: INFO
    root: info
    org.hibernate.SQL: info
    org.hibernate.orm.jdbc.batch: ERROR
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} %5p [%X{requestId}] --- [%thread] %-40.40logger{39} : %m%n"

# Observability 설정 (Issue #143)
observability:
  loki:
    url: ${LOKI_URL:http://localhost:3100}

# 넥손 API 설정
nexon:
  api:
    key: ${NEXON_API_KEY}
    # 타임아웃 설정 (기본값 - 필요 시 환경별로 오버라이드)
    connect-timeout: 3s              # TCP 연결 타임아웃
    response-timeout: 5s             # HTTP 응답 타임아웃
    cache-follower-timeout-seconds: 30  # Issue #225: 32s → 30s (TimeLimiter 28s + 여유 2s, Zombie Request 방지)
    latch-initial-ttl-seconds: 60    # 래치 초기 TTL (리더 크래시 대비)
    latch-finalize-ttl-seconds: 10   # 래치 정리 후 TTL (팔로워 조회 여유)

server:
  shutdown: graceful
  # Tomcat 스레드 설정 제거 - Virtual Thread 모드에서는 불필요
  tomcat:
    max-http-post-size: 262144  # 256KB (#266 P1-4: JSON DoS 방어)

app:
  optimization:
    use-compression: true
  aop:
    trace:
      enabled: true
  shutdown:
    backup-directory: /tmp/maple-shutdown
    archive-directory: /tmp/maple-shutdown/processed

# SpringDoc OpenAPI (Swagger UI) - Context7 Best Practice
springdoc:
  api-docs:
    enabled: true
    path: /v3/api-docs
  swagger-ui:
    enabled: true
    path: /swagger-ui.html
    operations-sorter: method
    tags-sorter: alpha
    try-it-out-enabled: true
    persist-authorization: true  # JWT 토큰 유지
  packages-to-scan: maple.expectation.controller
  show-actuator: false
  default-consumes-media-type: application/json
  default-produces-media-type: application/json

# Like Sync 설정 (Issue #147: Redis 원자성, Issue #48: 청킹)
like:
  sync:
    strategy: lua  # lua(기본) | rename(폴백) - Lua Script 미지원 환경용
    chunk-size: 500  # Issue #48: 청크 크기 (Green Agent 분석: MySQL InnoDB 최적값)
    recovery:
      enabled: true  # 서버 시작 시 Orphan Key 자동 복구 (@PostConstruct)
    temp-key-ttl-seconds: 3600  # 임시 키 TTL (1시간) - JVM 크래시 대비 안전장치

# BYOK 인증 설정 (Issue #146)
auth:
  jwt:
    secret: ${JWT_SECRET}  # 필수 환경변수 (미설정 시 앱 시작 실패)
    expiration: 1800  # 30분 (초)
  fingerprint:
    secret: ${FINGERPRINT_SECRET}  # 필수 환경변수 (미설정 시 앱 시작 실패)
  admin:
    allowlist: ${ADMIN_FINGERPRINTS:}  # 쉼표 구분 fingerprint 목록
  session:
    ttl: 1800  # 30분 (초)

# Expectation Buffer 설정 (#266 ADR 정합성)
expectation:
  buffer:
    shutdown-await-timeout-seconds: 30  # Shutdown 시 진행 중인 offer 대기 (초)
    cas-max-retries: 10                  # CAS 연산 최대 재시도 횟수
    max-queue-size: 10000                # 버퍼 최대 크기 (백프레셔 임계값)

# CORS 설정 (Issue #172: 환경별 분리)
# 주의: 반드시 환경별 프로필(local/prod)에서 allowed-origins 오버라이드 필요
cors:
  allowed-origins:
    - "http://localhost:3000"  # 기본값 (환경별 오버라이드 필수)
  allow-credentials: true
  max-age: 3600  # 1시간
