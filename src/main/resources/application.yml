spring:
  threads:
    virtual:
      enabled: true
  application:
    name: maple-expectation
  profiles:
    active: local # [Safety Guard] 별도 설정 없으면 무조건 로컬 모드
  lifecycle:
    timeout-per-shutdown-phase: 50s # Graceful Shutdown 시 충분한 시간 확보 (Equipment 대기 20s + Redis sync + 여유)

  # 공통 드라이버 설정
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      register-mbeans: true # JMX를 통해 지표 노출 활성화
      connection-timeout: 3000      # 커넥션 획득 타임아웃 3초 (Red Agent P1 Fix)
      leak-detection-threshold: 60000  # 60초 이상 반납 안되면 누수 의심 로그
      # [P0-N07 Fix] MDL Freeze 방지 - 세션 lock_wait_timeout 설정
      # 단일 문장만 지원 (P1-GREEN-01), MDL에는 lock_wait_timeout이 효과적
      # Issue #225: lock_wait_timeout 10s → 8s (Timeout Hierarchy 정렬 - Redis timeout과 동일)
      connection-init-sql: "SET SESSION lock_wait_timeout = 8"

  # 공통 JPA 설정
  jpa:
    open-in-view: false
    properties:
      hibernate:
        jdbc:
          batch_size: 1000
        format_sql: false
        show_sql: false

  # Spring Batch 설정 (Issue #251 Phase 4)
  batch:
    jdbc:
      initialize-schema: embedded  # 개발환경에서만 자동 생성
    job:
      enabled: false  # 스케줄러로만 트리거

management:
  endpoints:
    web:
      exposure:
        include: "health,info,metrics,prometheus,loggers"

  endpoint:
    health:
      show-details: always # 서킷 브레이커 상태를 상세히 보기 위해 필수
  health:
    circuitbreakers:
      enabled: true
  metrics:
    tags:
      application: ${spring.application.name} # 모든 메트릭에 앱 이름 태그 부여
  # OpenTelemetry tracing 설정 (Context7 Best Practice)
  tracing:
    enabled: ${OTEL_ENABLED:false}  # 기본 비활성화 (prod에서 true)
    sampling:
      probability: 0.05  # [P0-Green] 5% Head Sampling

resilience4j:
  circuitbreaker:
    circuit-breaker-aspect-order: 400
    configs:
      default:
        registerHealthIndicator: true
        slidingWindowSize: 10              # 최근 10번의 호출 기준
        failureRateThreshold: 50           # 실패율 50% 이상 시 Open
        waitDurationInOpenState: 10s       # Open 유지 시간
        permittedNumberOfCallsInHalfOpenState: 3
        ignoreExceptions:
          # 비즈니스 예외(404 등)는 실패로 카운트하지 않음
          - maple.expectation.global.error.exception.marker.CircuitBreakerIgnoreMarker
        recordExceptions:
          - maple.expectation.global.error.exception.marker.CircuitBreakerRecordMarker
    instances:
      nexonApi:
        baseConfig: default
        minimumNumberOfCalls: 10        # 최소 10번 호출 후 통계 산출 (Red Agent P1 Fix)
      likeSyncDb:  # Issue #48: Like Sync DB Batch Update 전용 Circuit Breaker
        baseConfig: default
        slidingWindowSize: 5            # 최근 5번의 청크 처리 기준
        failureRateThreshold: 60        # 60% 실패율에서 Open
        waitDurationInOpenState: 30s    # Open 후 30초 대기 (DB 복구 시간 확보)
        minimumNumberOfCalls: 3         # 최소 3번 호출 후 통계 산출
        permittedNumberOfCallsInHalfOpenState: 2
        registerHealthIndicator: true
      redisLock:  # Redis 분산 락 전용 Circuit Breaker
        slidingWindowSize: 20              # 락 작업은 빈번하므로 더 많은 샘플 수집
        failureRateThreshold: 60           # 60% 실패율에서 Open (락 경합은 정상적일 수 있음)
        waitDurationInOpenState: 30s       # Open 후 30초 대기 (Redis 복구 시간 확보)
        minimumNumberOfCalls: 5            # 최소 5번 호출 후 통계 산출
        permittedNumberOfCallsInHalfOpenState: 3
        registerHealthIndicator: true
        recordExceptions:                  # 이 예외들이 발생하면 실패로 간주
          - org.redisson.client.RedisException
          - org.redisson.client.RedisTimeoutException
          - java.util.concurrent.TimeoutException
      openAiApi:  # [P0-Red] Issue #251: OpenAI API Circuit Breaker
        baseConfig: default
        slidingWindowSize: 10
        failureRateThreshold: 50
        waitDurationInOpenState: 60s       # LLM 복구 시간 확보
        minimumNumberOfCalls: 5
        permittedNumberOfCallsInHalfOpenState: 3
        registerHealthIndicator: true

  bulkhead:
    instances:
      nexonApi:
        maxConcurrentCalls: 50          # 동시 Nexon API 호출 최대 50개
        maxWaitDuration: 500ms          # 대기 최대 500ms

  retry:
    retry-aspect-order: 399 # Retry가 CircuitBreaker를 감싸도록 설정
    instances:
      nexonApi:
        maxAttempts: 3
        waitDuration: 500ms
        retryExceptions:
          - java.util.concurrent.TimeoutException
          - io.netty.handler.timeout.ReadTimeoutException  # Reactor Netty responseTimeout 발생 시
          - org.springframework.web.reactive.function.client.WebClientRequestException # 네트워크 단절 대응
          - java.net.UnknownHostException
          - maple.expectation.global.error.exception.ExternalServiceException  # Issue #202: 외부 서비스 장애 시 재시도
      likeSyncRetry:  # P1-2: ResilienceConfig → YAML 이관
        maxAttempts: 3             # 최대 3번 시도 (처음 1번 + 재시도 2번)
        waitDuration: 1s           # 1초부터 시작
        enableExponentialBackoff: true
        exponentialBackoffMultiplier: 2.0
        retryExceptions:           # P1-9: 명시적 재시도 대상 (LikeSyncCircuitOpenException 제외)
          - org.springframework.dao.DataAccessException
          - org.springframework.jdbc.BadSqlGrammarException
          - java.sql.SQLException
      nexonLockRetry:
        maxAttempts: 5             # 최대 5번 시도 (락 경합이 심할 때를 대비해 조금 넓넉히)
        waitDuration: 200ms        # 0.2초 간격으로 다시 시도
        retryExceptions:           # 이 예외가 발생했을 때만 재시도함
          - maple.expectation.global.error.exception.DistributedLockException

  timelimiter:
    timelimiter-aspect-order: 398 # TimeLimiter → Retry → CircuitBreaker 순서
    instances:
      nexonApi:
        # 상한 예산: maxAttempts*(connect+response) + (maxAttempts-1)*wait + margin
        # = 3*(3s+5s) + 2*0.5s + 3s = 24 + 1 + 3 = 28s (3회 재시도 최악 시나리오 상한 보장)
        timeoutDuration: 28s        # 전체 작업 타임아웃 (3회 재시도 상한 보장)
        cancelRunningFuture: true   # 타임아웃 시 실행 중인 Future 취소

logging:
  level:
    org.springframework.cache: INFO
    maple.expectation.aop.aspect: INFO
    root: info
    org.hibernate.SQL: info
    org.hibernate.orm.jdbc.batch: ERROR
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} %5p [%X{requestId}] --- [%thread] %-40.40logger{39} : %m%n"

# Observability 설정 (Issue #143)
observability:
  loki:
    url: ${LOKI_URL:http://localhost:3100}

# 넥손 API 설정
nexon:
  api:
    key: ${NEXON_API_KEY}
    # 타임아웃 설정 (기본값 - 필요 시 환경별로 오버라이드)
    connect-timeout: 3s              # TCP 연결 타임아웃
    response-timeout: 5s             # HTTP 응답 타임아웃
    cache-follower-timeout-seconds: 30  # Issue #225: 32s → 30s (TimeLimiter 28s + 여유 2s, Zombie Request 방지)
    latch-initial-ttl-seconds: 60    # 래치 초기 TTL (리더 크래시 대비)
    latch-finalize-ttl-seconds: 10   # 래치 정리 후 TTL (팔로워 조회 여유)

server:
  shutdown: graceful
  # Tomcat 스레드 설정 제거 - Virtual Thread 모드에서는 불필요
  tomcat:
    max-http-post-size: 262144  # 256KB (#266 P1-4: JSON DoS 방어)
    uri-encoding: UTF-8  # 한글 URL 지원

app:
  instance-id: ${HOSTNAME:${random.uuid}}  # Issue #278: Scale-out Pub/Sub Self-skip용
  optimization:
    use-compression: true
  aop:
    trace:
      enabled: true
  shutdown:
    backup-directory: /tmp/maple-shutdown
    archive-directory: /tmp/maple-shutdown/processed
  buffer:
    redis:
      enabled: true  # V5 Stateless (#271): Redis Only 모드 활성화

# SpringDoc OpenAPI (Swagger UI) - Context7 Best Practice
springdoc:
  api-docs:
    enabled: true
    path: /v3/api-docs
  swagger-ui:
    enabled: true
    path: /swagger-ui.html
    operations-sorter: method
    tags-sorter: alpha
    try-it-out-enabled: true
    persist-authorization: true  # JWT 토큰 유지
  packages-to-scan: maple.expectation.controller
  show-actuator: false
  default-consumes-media-type: application/json
  default-produces-media-type: application/json

# Cache 설정 (P1-2: TTL/Size 외부화, P0-4: lockWaitSeconds)
cache:
  specs:
    equipment:
      l1-ttl-minutes: 5
      l1-max-size: 5000
      l2-ttl-minutes: 10
      l2-serializer: json
    cubeTrials:
      l1-ttl-minutes: 10
      l1-max-size: 5000
      l2-ttl-minutes: 20
      l2-serializer: jdk
    ocidCache:
      l1-ttl-minutes: 30
      l1-max-size: 5000
      l2-ttl-minutes: 60
      l2-serializer: json
    characterBasic:
      l1-ttl-minutes: 15
      l1-max-size: 5000
      l2-ttl-minutes: 15
      l2-serializer: json
    expectationV4:
      l1-ttl-minutes: 60
      l1-max-size: 5000
      l2-ttl-minutes: 60
      l2-serializer: jdk
  singleflight:
    lock-wait-seconds: 5  # P0-4 Fix: 30초 → 5초 (cold burst 스레드 고갈 방지)
  # Cache Invalidation 설정 (Issue #278: L1 Cache Coherence)
  invalidation:
    pubsub:
      enabled: true  # Scale-out 환경 L1 캐시 무효화 Pub/Sub 활성화

# Like Sync 설정 (Issue #147: Redis 원자성, Issue #48: 청킹)
like:
  sync:
    strategy: lua  # lua(기본) | rename(폴백) - Lua Script 미지원 환경용
    chunk-size: 500  # Issue #48: 청크 크기 (Green Agent 분석: MySQL InnoDB 최적값)
    recovery:
      enabled: true  # 서버 시작 시 Orphan Key 자동 복구 (@PostConstruct)
    temp-key-ttl-seconds: 3600  # 임시 키 TTL (1시간) - JVM 크래시 대비 안전장치
  # Issue #278: Scale-out 환경 실시간 좋아요 동기화
  realtime:
    enabled: true  # Pub/Sub 활성화 (인스턴스 간 L1 캐시 무효화)
    transport: rtopic  # rtopic(기본, at-most-once) | reliable-topic(at-least-once)

# BYOK 인증 설정 (Issue #146)
auth:
  jwt:
    secret: ${JWT_SECRET}  # 필수 환경변수 (미설정 시 앱 시작 실패)
    expiration: 900  # 15분 (초) - Issue #279: Access Token 단축
  refresh-token:
    expiration: 604800  # 7일 (초) - Issue #279: Refresh Token 도입
  fingerprint:
    secret: ${FINGERPRINT_SECRET}  # 필수 환경변수 (미설정 시 앱 시작 실패)
  admin:
    allowlist: ${ADMIN_FINGERPRINTS:}  # 쉼표 구분 fingerprint 목록
  session:
    ttl: 1800  # 30분 (초)

# Expectation Buffer 설정 (#266 ADR 정합성)
expectation:
  buffer:
    shutdown-await-timeout-seconds: 30  # Shutdown 시 진행 중인 offer 대기 (초)
    cas-max-retries: 10                  # CAS 연산 최대 재시도 횟수
    max-queue-size: 10000                # 버퍼 최대 크기 (백프레셔 임계값)

# 스케줄러 설정
scheduler:
  like-sync:
    enabled: true  # 좋아요 동기화 스케줄러 활성화
  warmup:
    enabled: false  # #275 Auto Warmup: 인기 캐릭터 자동 웜업 (prod에서 활성화)
    top-count: 50   # 웜업할 상위 캐릭터 수
    delay-between-ms: 100  # 요청 간 지연 (Thundering Herd 방지)

# CORS 설정 (Issue #172: 환경별 분리)
# 주의: 반드시 환경별 프로필(local/prod)에서 allowed-origins 오버라이드 필요
cors:
  allowed-origins:
    - "http://localhost:3000"  # 기본값 (환경별 오버라이드 필수)
  allow-credentials: true
  max-age: 3600  # 1시간

# MySQL Resilience 설정 (Issue #218: Stateless 아키텍처)
resilience:
  mysql-fallback:
    enabled: true
    # P1-2: Hash Tag 적용 (Redis Cluster 환경 동일 슬롯 보장)
    state-key: "{mysql}:state"
    ttl-lock-key: "{mysql}:ttl:lock"
    compensation-stream: "{mysql}:compensation:stream"
    compensation-dlq: "{mysql}:compensation:dlq"
    # P0-2: Debounce 설정 (Flapping 방지)
    debounce-seconds: 5
    # P1-N5: 상태 키 TTL (인스턴스 크래시 대비)
    state-ttl-seconds: 300  # 5분
    # P1-4: Sync 재시도 설정
    sync-batch-size: 100
    sync-max-retries: 3
    sync-consumer-group: compensation-sync
    # P0-1: 대상 캐시 패턴 (equipment, ocidCache만)
    target-cache-patterns:
      - "equipment:*"
      - "ocidCache:*"
    # P0-N2: SCAN 성능 설정
    scan-count: 1000
    # P1-N3: Stream MAXLEN (메모리 제한)
    stream-max-len: 10000
    # P1-1: 분산 락 설정
    lock-wait-seconds: 5
    lock-lease-seconds: 30

# ========================================
# Issue #251: AI SRE + OpenTelemetry
# ========================================

# LangChain4j OpenAI 설정 (Context7 Best Practice)
langchain4j:
  open-ai:
    chat-model:
      api-key: ${OPENAI_API_KEY:}
      model-name: gpt-4o-mini  # 비용 효율적인 모델
      temperature: 0.3  # 결정론적 응답 선호
      timeout: 30s
      log-requests: false
      log-responses: false

# AI SRE 설정
ai:
  sre:
    enabled: ${AI_SRE_ENABLED:false}  # 기본 비활성화 (prod에서 true)
    daily-limit: 100  # [P0-Green] 일일 LLM 호출 한도
    throttle-seconds: 60  # 동일 에러 패턴 스로틀링 간격
    max-concurrent-threads: 10  # Issue #283 P0-5: 동시 LLM 호출 최대 개수

# Spring Batch 설정 - spring.batch는 상단 spring: 블록에 병합됨

# OpenTelemetry 설정 - management.tracing은 상단 management: 블록에 병합됨

otel:
  exporter:
    otlp:
      endpoint: ${OTEL_EXPORTER_OTLP_ENDPOINT:http://localhost:4318}
      protocol: http/protobuf
  instrumentation:
    jdbc:
      statement-sanitizer: true  # [P0-Purple] SQL 파라미터 마스킹

# Redis 기반 Write-Behind 버퍼 (P1-2: Scale-out 지원)
# true: Redis Reliable Queue, false: In-Memory ConcurrentLinkedQueue
# → app.buffer.redis.enabled는 상단 app: 블록(line 184)에서 관리


# Thread Pool 설정 외부화 (P1-1)
# Lock DataSource Pool Size 외부화 (Issue #284 DoD)
lock:
  datasource:
    pool-size: 30  # 기본값 (prod에서 150으로 오버라이드)

executor:
  equipment:
    core-pool-size: 8
    max-pool-size: 16
    queue-capacity: 200
  preset:
    core-pool-size: 12
    max-pool-size: 24
    queue-capacity: 100

# Outbox 설정 (P1-8: 하드코딩 제거 → YAML 외부화)
outbox:
  batch-size: 100                   # SKIP LOCKED 배치 크기
  stale-threshold: 5m               # Stalled 판정 기준 (5분)
  max-backoff: 1h                   # Exponential Backoff 최대 대기 (1시간)
  instance-id: ${app.instance-id}   # Scale-out 인스턴스 식별자

# Graceful Shutdown 설정 (P1-1, P1-2, P1-3, P1-5: 하드코딩 제거 → YAML 외부화)
shutdown:
  equipment-await-timeout: 20s      # Equipment 비동기 저장 대기 타임아웃
  lock-wait-seconds: 3              # DB 동기화 분산 락 대기 시간
  lock-lease-seconds: 10            # DB 동기화 분산 락 점유 시간
  batch-size: 200                   # Shutdown 시 배치 크기
  empty-batch-retry-count: 3        # 빈 배치 재시도 횟수
  empty-batch-wait-ms: 100          # 빈 배치 간 대기 시간 (ms)
  backup-directory: /tmp/maple-shutdown
  archive-directory: /tmp/maple-shutdown/processed
  instance-id: ${app.instance-id}   # Scale-out 인스턴스 식별자
