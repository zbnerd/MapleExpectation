spring:
  threads:
    virtual:
      enabled: true
  application:
    name: maple-expectation
  profiles:
    active: local # [Safety Guard] 별도 설정 없으면 무조건 로컬 모드
  lifecycle:
    timeout-per-shutdown-phase: 50s # Graceful Shutdown 시 충분한 시간 확보 (Equipment 대기 20s + Redis sync + 여유)

  # 공통 드라이버 설정
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      register-mbeans: true # JMX를 통해 지표 노출 활성화

  # 공통 JPA 설정
  jpa:
    open-in-view: false
    properties:
      hibernate:
        jdbc:
          batch_size: 1000
        format_sql: false
        show_sql: false

management:
  endpoints:
    web:
      exposure:
        include: "health,info,metrics,prometheus,loggers"

  endpoint:
    health:
      show-details: always # 서킷 브레이커 상태를 상세히 보기 위해 필수
  health:
    circuitbreakers:
      enabled: true
  metrics:
    tags:
      application: ${spring.application.name} # 모든 메트릭에 앱 이름 태그 부여

resilience4j:
  circuitbreaker:
    circuit-breaker-aspect-order: 400
    configs:
      default:
        registerHealthIndicator: true
        slidingWindowSize: 10              # 최근 10번의 호출 기준
        failureRateThreshold: 50           # 실패율 50% 이상 시 Open
        waitDurationInOpenState: 10s       # Open 유지 시간
        permittedNumberOfCallsInHalfOpenState: 3
        ignoreExceptions:
          # 비즈니스 예외(404 등)는 실패로 카운트하지 않음
          - maple.expectation.global.error.exception.marker.CircuitBreakerIgnoreMarker
        recordExceptions:
          - maple.expectation.global.error.exception.marker.CircuitBreakerRecordMarker
    instances:
      nexonApi:
        baseConfig: default
      redisLock:  # Redis 분산 락 전용 Circuit Breaker
        slidingWindowSize: 20              # 락 작업은 빈번하므로 더 많은 샘플 수집
        failureRateThreshold: 60           # 60% 실패율에서 Open (락 경합은 정상적일 수 있음)
        waitDurationInOpenState: 30s       # Open 후 30초 대기 (Redis 복구 시간 확보)
        minimumNumberOfCalls: 5            # 최소 5번 호출 후 통계 산출
        permittedNumberOfCallsInHalfOpenState: 3
        registerHealthIndicator: true
        recordExceptions:                  # 이 예외들이 발생하면 실패로 간주
          - org.redisson.client.RedisException
          - org.redisson.client.RedisTimeoutException
          - java.util.concurrent.TimeoutException
          - maple.expectation.global.error.exception.DistributedLockException

  retry:
    retry-aspect-order: 399 # Retry가 CircuitBreaker를 감싸도록 설정
    instances:
      nexonApi:
        maxAttempts: 3
        waitDuration: 500ms
        retryExceptions:
          - java.util.concurrent.TimeoutException
          - io.netty.handler.timeout.ReadTimeoutException  # Reactor Netty responseTimeout 발생 시
          - org.springframework.web.reactive.function.client.WebClientRequestException # 네트워크 단절 대응
          - java.net.UnknownHostException
      nexonLockRetry:
        maxAttempts: 5             # 최대 5번 시도 (락 경합이 심할 때를 대비해 조금 넉넉히)
        waitDuration: 200ms        # 0.2초 간격으로 다시 시도
        retryExceptions:           # 이 예외가 발생했을 때만 재시도함
          - maple.expectation.global.error.exception.DistributedLockException

  timelimiter:
    timelimiter-aspect-order: 398 # TimeLimiter → Retry → CircuitBreaker 순서
    instances:
      nexonApi:
        # 상한 예산: maxAttempts*(connect+response) + (maxAttempts-1)*wait + margin
        # = 3*(3s+5s) + 2*0.5s + 3s = 24 + 1 + 3 = 28s (3회 재시도 최악 시나리오 상한 보장)
        timeoutDuration: 28s        # 전체 작업 타임아웃 (3회 재시도 상한 보장)
        cancelRunningFuture: true   # 타임아웃 시 실행 중인 Future 취소

logging:
  level:
    org.springframework.cache: INFO
    maple.expectation.aop.aspect: INFO
    root: info
    org.hibernate.SQL: info
    org.hibernate.orm.jdbc.batch: ERROR
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} %5p [%X{requestId}] --- [%thread] %-40.40logger{39} : %m%n"

# 넥슨 API 설정
nexon:
  api:
    key: ${NEXON_API_KEY}
    # 타임아웃 설정 (기본값 - 필요 시 환경별로 오버라이드)
    connect-timeout: 3s              # TCP 연결 타임아웃
    response-timeout: 5s             # HTTP 응답 타임아웃
    cache-follower-timeout-seconds: 32  # 캐시 Follower 대기 타임아웃 (TimeLimiter 28s + 여유 4s)
    latch-initial-ttl-seconds: 60    # 래치 초기 TTL (리더 크래시 대비)
    latch-finalize-ttl-seconds: 10   # 래치 정리 후 TTL (팔로워 조회 여유)

server:
  shutdown: graceful

app:
  optimization:
    use-compression: true
  aop:
    trace:
      enabled: true
  shutdown:
    backup-directory: /tmp/maple-shutdown
    archive-directory: /tmp/maple-shutdown/processed

# SpringDoc OpenAPI (Swagger UI) - Context7 Best Practice
springdoc:
  api-docs:
    enabled: true
    path: /v3/api-docs
  swagger-ui:
    enabled: true
    path: /swagger-ui.html
    operations-sorter: method
    tags-sorter: alpha
    try-it-out-enabled: true
    persist-authorization: true  # JWT 토큰 유지
  packages-to-scan: maple.expectation.controller
  show-actuator: false
  default-consumes-media-type: application/json
  default-produces-media-type: application/json

# BYOK 인증 설정 (Issue #146)
auth:
  jwt:
    secret: ${JWT_SECRET:dev-secret-key-must-be-at-least-32-characters-long}
    expiration: 1800  # 30분 (초)
  fingerprint:
    secret: ${FINGERPRINT_SECRET:fingerprint-secret-key-for-hmac-sha256}
  admin:
    allowlist: ${ADMIN_FINGERPRINTS:}  # 쉼표 구분 fingerprint 목록
  session:
    ttl: 1800  # 30분 (초)