package maple.expectation.infrastructure.messaging;

import maple.expectation.application.port.EventPublisher;
import maple.expectation.domain.event.IntegrationEvent;
import maple.expectation.global.error.exception.QueuePublishException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

/**
 * Kafka-based event publisher implementation (Future - Phase 8).
 *
 * <p><strong>Concrete Strategy B:</strong> Will be used when project migrates to Kafka
 * (Phase 8: Event-Driven Architecture & MSA). Currently a stub for future implementation.
 *
 * <p><strong>Configuration:</strong> Activated when {@code app.event-publisher.type=kafka}.
 * To use Kafka:
 * <ol>
 *   <li>Add {@code spring-kafka} dependency to build.gradle</li>
 *   <li>Configure Kafka broker in application.yml</li>
 *   <li>Set {@code app.event-publisher.type=kafka}</li>
 * </ol>
 *
 * <p><strong>Migration Path from Redis:</strong>
 * <pre>{@code
 * # Current (Phase 1-7)
 * app:
 *   event-publisher:
 *     type: redis
 *
 * # Future (Phase 8+)
 * app:
 *   event-publisher:
 *     type: kafka
 * }</pre>
 *
 * <p><strong>Kafka Benefits over Redis:</strong>
 * <table border="1">
 *   <tr><th>Aspect</th><th>Redis (Current)</th><th>Kafka (Phase 8)</th></tr>
 *   <tr><td>Throughput</td><td>~10K msg/s</td><td>~100K+ msg/s</td></tr>
 *   <tr><td>Persistence</td><td>AOF (configurable)</td><td>Log-based (durable)</td></tr>
 *   <tr><td>Replay</td><td>Limited</td><td>Offset-based replay</td></tr>
 *   <tr><td>Consumer Groups</td><td>None</td><td>Native support</td></tr>
 * </table>
 *
 * <p><strong>Design Notes:</strong>
 * <ul>
 *   <li>Uses KafkaTemplate for sending messages</li>
 *   <li>eventId is used as message key for ordering</li>
 *   <li>CompletableFuture from KafkaTemplate.send() is returned</li>
 *   <li>Falls back to async wrapper if KafkaTemplate returns void</li>
 * </ul>
 *
 * @see EventPublisher
 * @see maple.expectation.infrastructure.messaging.RedisEventPublisher
 * @see ADR-018 Strategy Pattern for ACL
 * @see <a href="https://kafka.apache.org/documentation/">Apache Kafka Documentation</a>
 */
@Slf4j
@Component
@RequiredArgsConstructor
@ConditionalOnProperty(name = "app.event-publisher.type", havingValue = "kafka")
public class KafkaEventPublisher implements EventPublisher {

  private final KafkaTemplate<String, String> kafkaTemplate;
  private final com.fasterxml.jackson.databind.ObjectMapper objectMapper;

  @Override
  public void publish(String topic, IntegrationEvent<?> event) {
    try {
      // Serialize IntegrationEvent to JSON
      String jsonPayload = objectMapper.writeValueAsString(event);

      // Send to Kafka (eventId as key for ordering)
      kafkaTemplate.send(topic, event.getEventId(), jsonPayload);

      log.debug("[KafkaEventPublisher] Published to topic {}: eventId={}, eventType={}",
          topic, event.getEventId(), event.getEventType());

    } catch (Exception e) {
      log.error("[KafkaEventPublisher] Failed to publish to topic {}: eventId={}, eventType={}",
          topic, event.getEventId(), event.getEventType(), e);

      throw new QueuePublishException(
          String.format("Kafka publish failed: topic=%s, eventType=%s", topic, event.getEventType()),
          e
      );
    }
  }

  @Override
  public java.util.concurrent.CompletableFuture<Void> publishAsync(
      String topic,
      IntegrationEvent<?> event) {

    try {
      // Serialize IntegrationEvent to JSON
      String jsonPayload = objectMapper.writeValueAsString(event);

      // KafkaTemplate.send() returns CompletableFuture - use it directly
      return kafkaTemplate.send(topic, event.getEventId(), jsonPayload)
          .thenApply(result -> {
            log.debug("[KafkaEventPublisher] Published to topic {}: eventId={}, eventType={}",
                topic, event.getEventId(), event.getEventType());
            return null;
          })
          .exceptionally(ex -> {
            log.error("[KafkaEventPublisher] Failed to publish to topic {}: eventId={}, eventType={}",
                topic, event.getEventId(), event.getEventType(), ex);
            throw new QueuePublishException(
                String.format("Kafka publish failed: topic=%s, eventType=%s", topic, event.getEventType()),
                ex
            );
          });

    } catch (Exception e) {
      // Serialization error (fail-fast)
      log.error("[KafkaEventPublisher] Failed to serialize event: eventType={}",
          event.getEventType(), e);
      throw new QueuePublishException(
          String.format("Kafka serialization failed: eventType=%s", event.getEventType()),
          e
      );
    }
  }
}
