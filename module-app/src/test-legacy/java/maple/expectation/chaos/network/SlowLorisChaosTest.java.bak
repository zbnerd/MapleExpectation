package maple.expectation.chaos.network;
import org.junit.jupiter.api.Disabled;

import eu.rekawek.toxiproxy.model.ToxicDirection;
import maple.expectation.support.AbstractContainerBaseTest;
import org.junit.jupiter.api.*;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.RedisTemplate;

import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Scenario 06: Slow Loris - Zombie API (ëŠë¦° ì‘ë‹µ)
 *
 * <h4>5-Agent Council</h4>
 * <ul>
 *   <li>ğŸ”´ Red (SRE): ì¥ì•  ì£¼ì… - Toxiproxyë¡œ ë„¤íŠ¸ì›Œí¬ ì§€ì—°(latency) ì£¼ì…</li>
 *   <li>ğŸŸ£ Purple (Auditor): ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦ - íƒ€ì„ì•„ì›ƒ í›„ ë°ì´í„° ì •í•©ì„±</li>
 *   <li>ğŸ”µ Blue (Architect): íë¦„ ê²€ì¦ - Fail-Fast ì›ì¹™ ë° íƒ€ì„ì•„ì›ƒ ì „íŒŒ</li>
 *   <li>ğŸŸ¢ Green (Performance): ë©”íŠ¸ë¦­ ê²€ì¦ - ì‘ë‹µ ì‹œê°„ ë¶„í¬, íƒ€ì„ì•„ì›ƒ ë¹„ìœ¨</li>
 *   <li>ğŸŸ¡ Yellow (QA Master): í…ŒìŠ¤íŠ¸ ì „ëµ - ê²½ê³„ê°’ í…ŒìŠ¤íŠ¸ (íƒ€ì„ì•„ì›ƒ ì„ê³„ì¹˜)</li>
 * </ul>
 *
 * <h4>ê²€ì¦ í¬ì¸íŠ¸</h4>
 * <ol>
 *   <li>ëŠë¦° ì‘ë‹µì´ ì „ì²´ ì‹œìŠ¤í…œì„ ë¸”ë¡œí‚¹í•˜ì§€ ì•ŠëŠ”ì§€ (Fail-Fast)</li>
 *   <li>íƒ€ì„ì•„ì›ƒì´ ì •í™•íˆ ì‘ë™í•˜ëŠ”ì§€</li>
 *   <li>ëŠë¦° ì‘ë‹µ í›„ ë³µêµ¬ê°€ ì •ìƒì ì¸ì§€</li>
 *   <li>ë¶„ì‚° ë½ì´ ëŠë¦° ë„¤íŠ¸ì›Œí¬ì—ì„œë„ ì•ˆì „í•˜ê²Œ ë™ì‘í•˜ëŠ”ì§€</li>
 * </ol>
 *
 * <h4>CS ì›ë¦¬</h4>
 * <ul>
 *   <li>Slow Loris Attack: ì—°ê²°ì„ ëŠë¦¬ê²Œ ìœ ì§€í•˜ì—¬ ë¦¬ì†ŒìŠ¤ ê³ ê°ˆ</li>
 *   <li>Fail-Fast Principle: ë¹ ë¥¸ ì‹¤íŒ¨ë¡œ ë¦¬ì†ŒìŠ¤ í•´ì œ</li>
 *   <li>Timeout Propagation: íƒ€ì„ì•„ì›ƒì˜ ì „íŒŒì™€ ì „ì²´ ì˜ˆì‚° ê´€ë¦¬</li>
 *   <li>Back-pressure: ëŠë¦° í•˜ìœ„ ì‹œìŠ¤í…œì— ëŒ€í•œ ì••ë ¥ ì œì–´</li>
 * </ul>
 *
 * @see org.testcontainers.containers.ToxiproxyContainer
 */
@Tag("chaos")
@Disabled("ToxiProxy integration needs setup - Phase 3 prep")
@SpringBootTest
@DisplayName("Scenario 06: Slow Loris - ëŠë¦° ì‘ë‹µ ë° íƒ€ì„ì•„ì›ƒ ê²€ì¦")
class SlowLorisChaosTest extends AbstractContainerBaseTest {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    @Autowired
    private RedissonClient redissonClient;

    private static final String SLOW_LORIS_KEY = "slow-loris:test";
    private static final int LATENCY_MS = 3000; // 3ì´ˆ ì§€ì—°

    @BeforeEach
    void setUp() {
        try {
            redisTemplate.delete(SLOW_LORIS_KEY);
        } catch (Exception ignored) {
        }
    }

    /**
     * ğŸ”´ Red's Test 1: ë„¤íŠ¸ì›Œí¬ ì§€ì—° ì£¼ì… ì‹œ íƒ€ì„ì•„ì›ƒ ë™ì‘ ê²€ì¦
     *
     * <p><b>ì‹œë‚˜ë¦¬ì˜¤</b>:
     * <ol>
     *   <li>Toxiproxyë¡œ 3ì´ˆ ì§€ì—° ì£¼ì…</li>
     *   <li>Redis ì‘ì—… ì‹œë„ (íƒ€ì„ì•„ì›ƒ 2ì´ˆ ì„¤ì •)</li>
     *   <li>ì˜ˆìƒ: íƒ€ì„ì•„ì›ƒ ë°œìƒ (Fail-Fast)</li>
     * </ol>
     */
    @Test
    @DisplayName("ë„¤íŠ¸ì›Œí¬ ì§€ì—° ì‹œ Fail-Fast íƒ€ì„ì•„ì›ƒ ë™ì‘")
    void shouldTimeout_whenNetworkLatencyInjected() throws Exception {
        // Given: Toxiproxyë¡œ 3ì´ˆ ì§€ì—° ì£¼ì…
        redisProxy.toxics()
                .latency("slow-loris-latency", ToxicDirection.DOWNSTREAM, LATENCY_MS);

        System.out.println("[Red] Injected " + LATENCY_MS + "ms latency via Toxiproxy");

        // When: ë¹ ë¥¸ íƒ€ì„ì•„ì›ƒìœ¼ë¡œ Redis ì‘ì—… ì‹œë„
        long startTime = System.nanoTime();
        String result = null;
        Exception caughtException = null;

        try {
            // ë¨¼ì € ê°’ ì„¤ì • ì‹œë„ (ì§€ì—° ë°œìƒ)
            CompletableFuture<Void> future = CompletableFuture.runAsync(() ->
                    redisTemplate.opsForValue().set(SLOW_LORIS_KEY, "test-value")
            );

            // 2ì´ˆ íƒ€ì„ì•„ì›ƒ ì ìš© (3ì´ˆ ì§€ì—°ë³´ë‹¤ ì§§ìŒ)
            future.get(2, TimeUnit.SECONDS);
        } catch (TimeoutException e) {
            caughtException = e;
            System.out.println("[Red] TimeoutException caught as expected!");
        } catch (Exception e) {
            caughtException = e;
            System.out.println("[Red] Exception caught: " + e.getClass().getSimpleName());
        }

        long elapsedMs = (System.nanoTime() - startTime) / 1_000_000;

        // Then: íƒ€ì„ì•„ì›ƒì´ 2ì´ˆ ë‚´ì— ë°œìƒ
        System.out.printf("[Green] Elapsed time: %dms (expected: ~2000ms)%n", elapsedMs);
        assertThat(caughtException).isNotNull();
        assertThat(elapsedMs)
                .as("íƒ€ì„ì•„ì›ƒì´ ì„¤ì • ì‹œê°„(2ì´ˆ) ê·¼ì²˜ì—ì„œ ë°œìƒí•´ì•¼ í•¨")
                .isBetween(1500L, 2500L);
    }

    /**
     * ğŸŸ¢ Green's Test 2: ëŠë¦° ì‘ë‹µ í›„ ì •ìƒ ë³µêµ¬ í™•ì¸
     *
     * <p><b>ì‹œë‚˜ë¦¬ì˜¤</b>:
     * <ol>
     *   <li>ì§€ì—° ì£¼ì… í›„ ì¼ë¶€ ìš”ì²­ íƒ€ì„ì•„ì›ƒ</li>
     *   <li>ì§€ì—° ì œê±°</li>
     *   <li>ì •ìƒ ì‘ë‹µ í™•ì¸</li>
     * </ol>
     */
    @Test
    @DisplayName("ì§€ì—° ì œê±° í›„ ì •ìƒ ì‘ë‹µ ë³µêµ¬")
    void shouldRecover_afterLatencyRemoved() throws Exception {
        // Phase 1: ì§€ì—° ì£¼ì…
        redisProxy.toxics()
                .latency("recovery-test-latency", ToxicDirection.DOWNSTREAM, 2000);

        System.out.println("[Red] Phase 1: Injected 2000ms latency");

        // ì§€ì—° ìƒíƒœì—ì„œ ì‘ë‹µ ì‹œê°„ ì¸¡ì •
        long slowStart = System.nanoTime();
        try {
            redisTemplate.opsForValue().set(SLOW_LORIS_KEY, "slow-value");
        } catch (Exception e) {
            System.out.println("[Red] Exception during slow phase: " + e.getMessage());
        }
        long slowElapsed = (System.nanoTime() - slowStart) / 1_000_000;
        System.out.printf("[Green] Slow phase elapsed: %dms%n", slowElapsed);

        // Phase 2: ì§€ì—° ì œê±°
        redisProxy.toxics().get("recovery-test-latency").remove();
        System.out.println("[Red] Phase 2: Latency removed");

        // ì •ìƒ ìƒíƒœì—ì„œ ì‘ë‹µ ì‹œê°„ ì¸¡ì •
        long fastStart = System.nanoTime();
        redisTemplate.opsForValue().set(SLOW_LORIS_KEY, "fast-value");
        String result = redisTemplate.opsForValue().get(SLOW_LORIS_KEY);
        long fastElapsed = (System.nanoTime() - fastStart) / 1_000_000;

        System.out.printf("[Green] Fast phase elapsed: %dms%n", fastElapsed);
        System.out.printf("[Green] Recovery improvement: %dx faster%n",
                slowElapsed > 0 ? slowElapsed / Math.max(fastElapsed, 1) : 0);

        // Then: ë³µêµ¬ í›„ ì •ìƒ ë™ì‘
        assertThat(result).isEqualTo("fast-value");
        assertThat(fastElapsed)
                .as("ë³µêµ¬ í›„ ì‘ë‹µ ì‹œê°„ì€ 100ms ë¯¸ë§Œì´ì–´ì•¼ í•¨")
                .isLessThan(100L);
    }

    /**
     * ğŸ”µ Blue's Test 3: ë¶„ì‚° ë½ì˜ ëŠë¦° ë„¤íŠ¸ì›Œí¬ ë‚´êµ¬ì„±
     *
     * <p><b>ì‹œë‚˜ë¦¬ì˜¤</b>: ì§€ì—°ì´ ìˆì–´ë„ ë¶„ì‚° ë½ì´ ì•ˆì „í•˜ê²Œ ë™ì‘í•˜ëŠ”ì§€ ê²€ì¦
     */
    @Test
    @DisplayName("ë¶„ì‚° ë½ì€ ëŠë¦° ë„¤íŠ¸ì›Œí¬ì—ì„œë„ ì•ˆì „í•˜ê²Œ ë™ì‘")
    void shouldMaintainLockSafety_underSlowNetwork() throws Exception {
        RLock lock = redissonClient.getLock("slow-loris:lock-safety");
        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger timeoutCount = new AtomicInteger(0);

        // 500ms ì§€ì—° ì£¼ì… (ë½ ì‘ì—…ì— ì˜í–¥ì„ ì£¼ì§€ë§Œ ì™„ì „ ì‹¤íŒ¨í•˜ì§€ëŠ” ì•ŠìŒ)
        redisProxy.toxics()
                .latency("lock-latency", ToxicDirection.DOWNSTREAM, 500);

        System.out.println("[Blue] Injected 500ms latency for lock test");

        // ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ë½ íšë“ ì‹œë„
        ExecutorService executor = Executors.newFixedThreadPool(3);
        CountDownLatch latch = new CountDownLatch(3);

        for (int i = 0; i < 3; i++) {
            final int threadId = i + 1;
            executor.submit(() -> {
                try {
                    long start = System.nanoTime();
                    // waitTimeì„ ì¶©ë¶„íˆ ëŠ˜ë ¤ì„œ ì§€ì—°ì„ ê°ì•ˆ
                    boolean acquired = lock.tryLock(10, 2, TimeUnit.SECONDS);
                    long elapsed = (System.nanoTime() - start) / 1_000_000;

                    if (acquired) {
                        try {
                            successCount.incrementAndGet();
                            System.out.printf("[Blue] Thread %d acquired lock in %dms%n", threadId, elapsed);
                            Thread.sleep(100);
                        } finally {
                            lock.unlock();
                        }
                    } else {
                        timeoutCount.incrementAndGet();
                        System.out.printf("[Blue] Thread %d timed out after %dms%n", threadId, elapsed);
                    }
                } catch (Exception e) {
                    System.out.printf("[Blue] Thread %d exception: %s%n", threadId, e.getMessage());
                    timeoutCount.incrementAndGet();
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await(30, TimeUnit.SECONDS);
        executor.shutdown();

        System.out.printf("[Green] Success: %d, Timeout: %d%n",
                successCount.get(), timeoutCount.get());

        // ìµœì†Œ 1ê°œ ì´ìƒì˜ ìŠ¤ë ˆë“œê°€ ë½ì„ íšë“í•´ì•¼ í•¨
        assertThat(successCount.get())
                .as("ëŠë¦° ë„¤íŠ¸ì›Œí¬ì—ì„œë„ ìµœì†Œ 1ê°œ ìŠ¤ë ˆë“œëŠ” ë½ íšë“ ì„±ê³µ")
                .isGreaterThanOrEqualTo(1);
    }

    /**
     * ğŸŸ£ Purple's Test 4: ì ì§„ì  ì§€ì—° ì¦ê°€ ì‹œ ì‹œìŠ¤í…œ ë°˜ì‘
     *
     * <p><b>ì‹œë‚˜ë¦¬ì˜¤</b>: ì§€ì—°ì´ ì ì§„ì ìœ¼ë¡œ ì¦ê°€í•  ë•Œ ì‹œìŠ¤í…œì´ ì ì ˆíˆ ë°˜ì‘í•˜ëŠ”ì§€
     */
    @Test
    @DisplayName("ì ì§„ì  ì§€ì—° ì¦ê°€ ì‹œ ì‹œìŠ¤í…œ ë°˜ì‘ ë¶„ì„")
    void shouldAnalyze_gradualLatencyIncrease() throws Exception {
        int[] latencies = {100, 500, 1000, 2000};
        long[] responseTimes = new long[latencies.length];

        System.out.println("[Purple] Starting gradual latency analysis...");
        System.out.println("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
        System.out.println("â”‚               Latency vs Response Time Analysis            â”‚");
        System.out.println("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤");

        for (int i = 0; i < latencies.length; i++) {
            // ì´ì „ toxic ì œê±°
            try {
                redisProxy.toxics().get("gradual-latency").remove();
            } catch (Exception ignored) {}

            // ìƒˆ ì§€ì—° ì£¼ì…
            redisProxy.toxics()
                    .latency("gradual-latency", ToxicDirection.DOWNSTREAM, latencies[i]);

            // ì‘ë‹µ ì‹œê°„ ì¸¡ì •
            long start = System.nanoTime();
            try {
                redisTemplate.opsForValue().set(SLOW_LORIS_KEY, "test-" + i);
                redisTemplate.opsForValue().get(SLOW_LORIS_KEY);
            } catch (Exception e) {
                // íƒ€ì„ì•„ì›ƒ ë°œìƒ ì‹œ í˜„ì¬ ì‹œê°„ê¹Œì§€ë¥¼ ì‘ë‹µ ì‹œê°„ìœ¼ë¡œ ê¸°ë¡
            }
            responseTimes[i] = (System.nanoTime() - start) / 1_000_000;

            System.out.printf("â”‚ Injected Latency: %4dms â”‚ Response Time: %5dms      â”‚%n",
                    latencies[i], responseTimes[i]);
        }

        System.out.println("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");

        // ì‘ë‹µ ì‹œê°„ì´ ì£¼ì…ëœ ì§€ì—°ê³¼ ë¹„ë¡€í•´ì„œ ì¦ê°€í•´ì•¼ í•¨
        for (int i = 0; i < latencies.length; i++) {
            assertThat(responseTimes[i])
                    .as("ì‘ë‹µ ì‹œê°„ì€ ì£¼ì…ëœ ì§€ì—°(%dms)ë³´ë‹¤ ê¸¸ì–´ì•¼ í•¨", latencies[i])
                    .isGreaterThanOrEqualTo(latencies[i]);
        }
    }

    /**
     * ğŸŸ¡ Yellow's Test 5: íƒ€ì„ì•„ì›ƒ ê²½ê³„ê°’ í…ŒìŠ¤íŠ¸
     *
     * <p><b>ì‹œë‚˜ë¦¬ì˜¤</b>: íƒ€ì„ì•„ì›ƒ ì„ê³„ì¹˜ ê·¼ì²˜ì—ì„œì˜ ë™ì‘ ê²€ì¦
     */
    @Test
    @DisplayName("íƒ€ì„ì•„ì›ƒ ê²½ê³„ê°’ì—ì„œ Fail-Fast ë™ì‘")
    void shouldFailFast_atTimeoutBoundary() throws Exception {
        // ì •í™•íˆ íƒ€ì„ì•„ì›ƒ ê²½ê³„(1ì´ˆ)ì— ê°€ê¹Œìš´ ì§€ì—° í…ŒìŠ¤íŠ¸
        int boundaryLatency = 1100; // 1.1ì´ˆ
        int timeout = 1000; // 1ì´ˆ íƒ€ì„ì•„ì›ƒ

        redisProxy.toxics()
                .latency("boundary-latency", ToxicDirection.DOWNSTREAM, boundaryLatency);

        System.out.printf("[Yellow] Testing boundary: %dms latency vs %dms timeout%n",
                boundaryLatency, timeout);

        Instant start = Instant.now();
        boolean timedOut = false;

        try {
            CompletableFuture<String> future = CompletableFuture.supplyAsync(() ->
                    redisTemplate.opsForValue().get(SLOW_LORIS_KEY)
            );
            future.get(timeout, TimeUnit.MILLISECONDS);
        } catch (TimeoutException e) {
            timedOut = true;
        } catch (Exception e) {
            System.out.println("[Yellow] Other exception: " + e.getClass().getSimpleName());
        }

        Duration elapsed = Duration.between(start, Instant.now());
        System.out.printf("[Yellow] Result: timedOut=%s, elapsed=%dms%n",
                timedOut, elapsed.toMillis());

        // íƒ€ì„ì•„ì›ƒì´ ë°œìƒí•´ì•¼ í•˜ê³ , ëŒ€ê¸° ì‹œê°„ì´ íƒ€ì„ì•„ì›ƒ ì„¤ì • ê·¼ì²˜ì—¬ì•¼ í•¨
        assertThat(timedOut).as("ì§€ì—°ì´ íƒ€ì„ì•„ì›ƒë³´ë‹¤ ê¸¸ë©´ íƒ€ì„ì•„ì›ƒ ë°œìƒ").isTrue();
        assertThat(elapsed.toMillis())
                .as("íƒ€ì„ì•„ì›ƒì€ ì„¤ì • ì‹œê°„(1ì´ˆ) ê·¼ì²˜ì—ì„œ ë°œìƒ")
                .isBetween(800L, 1500L);
    }
}
