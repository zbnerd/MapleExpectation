package maple.expectation.chaos.resource;
import org.junit.jupiter.api.Disabled;

import eu.rekawek.toxiproxy.model.ToxicDirection;
import maple.expectation.support.AbstractContainerBaseTest;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.RedisTemplate;

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Scenario 09: Retry Storm - ì¬ì‹œë„ í­í’
 *
 * <h4>5-Agent Council</h4>
 * <ul>
 *   <li>ğŸ”´ Red (SRE): ì¥ì•  ì£¼ì… - ì¼ì‹œì  ì¥ì• ë¡œ ëŒ€ëŸ‰ ì¬ì‹œë„ ìœ ë°œ</li>
 *   <li>ğŸ”µ Blue (Architect): íë¦„ ê²€ì¦ - Exponential Backoff ë™ì‘</li>
 *   <li>ğŸŸ¢ Green (Performance): ë©”íŠ¸ë¦­ ê²€ì¦ - ì¬ì‹œë„ íšŸìˆ˜ ë° ë¶€í•˜ ì¸¡ì •</li>
 *   <li>ğŸŸ¡ Yellow (QA Master): í…ŒìŠ¤íŠ¸ ì „ëµ - Retry Budget ê²€ì¦</li>
 * </ul>
 *
 * <h4>ê²€ì¦ í¬ì¸íŠ¸</h4>
 * <ol>
 *   <li>ë™ì‹œ ì¬ì‹œë„ê°€ ì‹œìŠ¤í…œì„ ì••ë„í•˜ì§€ ì•ŠëŠ”ì§€</li>
 *   <li>Exponential Backoffê°€ ì œëŒ€ë¡œ ì‘ë™í•˜ëŠ”ì§€</li>
 *   <li>Retry Budgetì´ ì¬ì‹œë„ í­ì£¼ë¥¼ ì œí•œí•˜ëŠ”ì§€</li>
 *   <li>Circuit Breakerê°€ ì¬ì‹œë„ í­í’ì„ ì°¨ë‹¨í•˜ëŠ”ì§€</li>
 * </ol>
 *
 * @see io.github.resilience4j.retry.Retry
 */
@Tag("chaos")
@Disabled("ToxiProxy integration needs setup - Phase 3 prep")
@SpringBootTest
@DisplayName("Scenario 09: Retry Storm - ì¬ì‹œë„ í­í’ ë° Backoff ê²€ì¦")
class RetryStormChaosTest extends AbstractContainerBaseTest {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    private static final String RETRY_STORM_KEY = "retry-storm:test";

    @BeforeEach
    void setUp() {
        try {
            redisTemplate.delete(RETRY_STORM_KEY);
        } catch (Exception ignored) {
        }
    }

    /**
     * ğŸ”´ Red's Test 1: ì¼ì‹œì  ì¥ì• ê°€ ì¬ì‹œë„ í­í’ì„ ìœ ë°œí•˜ëŠ”ì§€ ê²€ì¦
     */
    @Test
    @DisplayName("ì¼ì‹œì  ì¥ì•  ì‹œ ì¬ì‹œë„ íšŸìˆ˜ ì œí•œ í™•ì¸")
    void shouldLimitRetries_duringTemporaryFailure() throws Exception {
        int concurrentClients = 10;
        AtomicInteger totalAttempts = new AtomicInteger(0);
        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger failureCount = new AtomicInteger(0);

        ExecutorService executor = Executors.newFixedThreadPool(concurrentClients);
        CountDownLatch startLatch = new CountDownLatch(1);
        CountDownLatch doneLatch = new CountDownLatch(concurrentClients);

        // 2ì´ˆ ì§€ì—° ì£¼ì… (íƒ€ì„ì•„ì›ƒ ìœ ë°œ)
        redisProxy.toxics()
                .latency("retry-storm-latency", ToxicDirection.DOWNSTREAM, 2000);

        System.out.println("[Red] Injected 2000ms latency to trigger retries");

        for (int i = 0; i < concurrentClients; i++) {
            final int clientId = i;
            executor.submit(() -> {
                try {
                    startLatch.await();

                    int maxRetries = 3;
                    int attempts = 0;
                    boolean success = false;

                    while (attempts < maxRetries && !success) {
                        attempts++;
                        totalAttempts.incrementAndGet();

                        try {
                            CompletableFuture<Void> future = CompletableFuture.runAsync(() ->
                                    redisTemplate.opsForValue().set(RETRY_STORM_KEY + ":" + clientId, "value")
                            );
                            future.get(1, TimeUnit.SECONDS);
                            success = true;
                        } catch (Exception e) {
                            // Exponential Backoff (100ms * 2^attempt)
                            Thread.sleep(100L * (1L << attempts));
                        }
                    }

                    if (success) {
                        successCount.incrementAndGet();
                    } else {
                        failureCount.incrementAndGet();
                    }
                } catch (Exception e) {
                    failureCount.incrementAndGet();
                } finally {
                    doneLatch.countDown();
                }
            });
        }

        startLatch.countDown();
        doneLatch.await(30, TimeUnit.SECONDS);
        executor.shutdown();

        // ì •ë¦¬
        redisProxy.toxics().get("retry-storm-latency").remove();

        System.out.println("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
        System.out.println("â”‚               Retry Storm Analysis                         â”‚");
        System.out.println("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤");
        System.out.printf("â”‚ Concurrent Clients: %d                                      â”‚%n", concurrentClients);
        System.out.printf("â”‚ Total Attempts: %d (max possible: %d)                       â”‚%n",
                totalAttempts.get(), concurrentClients * 3);
        System.out.printf("â”‚ Success Count: %d                                           â”‚%n", successCount.get());
        System.out.printf("â”‚ Failure Count: %d                                           â”‚%n", failureCount.get());
        System.out.printf("â”‚ Retry Amplification: %.1fx                                  â”‚%n",
                (double) totalAttempts.get() / concurrentClients);
        System.out.println("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");

        // ê²€ì¦: ì¬ì‹œë„ íšŸìˆ˜ê°€ í•©ë¦¬ì ì¸ ë²”ìœ„ ë‚´
        assertThat(totalAttempts.get())
                .as("ì¬ì‹œë„ íšŸìˆ˜ê°€ ìµœëŒ€ í—ˆìš©ì¹˜ ì´ë‚´")
                .isLessThanOrEqualTo(concurrentClients * 3);
    }

    /**
     * ğŸ”µ Blue's Test 2: Exponential Backoff ë™ì‘ ê²€ì¦
     */
    @Test
    @DisplayName("Exponential Backoffê°€ ì¬ì‹œë„ ê°„ê²©ì„ ì¦ê°€ì‹œí‚´")
    void shouldIncreaseBackoffExponentially() throws Exception {
        long[] retryIntervals = new long[3];

        // 500ms ì§€ì—°ìœ¼ë¡œ íƒ€ì„ì•„ì›ƒ ìœ ë°œ
        redisProxy.toxics()
                .latency("backoff-latency", ToxicDirection.DOWNSTREAM, 500);

        System.out.println("[Blue] Testing Exponential Backoff pattern...");

        long lastAttemptTime = System.nanoTime();

        for (int attempt = 0; attempt < 3; attempt++) {
            long currentTime = System.nanoTime();
            if (attempt > 0) {
                retryIntervals[attempt] = (currentTime - lastAttemptTime) / 1_000_000;
            }
            lastAttemptTime = currentTime;

            try {
                CompletableFuture<String> future = CompletableFuture.supplyAsync(() ->
                        redisTemplate.opsForValue().get(RETRY_STORM_KEY)
                );
                future.get(200, TimeUnit.MILLISECONDS);
            } catch (Exception e) {
                // Exponential Backoff: 100, 200, 400ms
                long backoff = 100L * (1L << attempt);
                System.out.printf("[Blue] Attempt %d failed, backing off %dms%n", attempt + 1, backoff);
                Thread.sleep(backoff);
            }
        }

        // ì •ë¦¬
        redisProxy.toxics().get("backoff-latency").remove();

        System.out.println("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
        System.out.println("â”‚               Exponential Backoff Analysis                 â”‚");
        System.out.println("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤");
        System.out.printf("â”‚ Interval 1â†’2: %dms (expected: ~100ms + execution)          â”‚%n", retryIntervals[1]);
        System.out.printf("â”‚ Interval 2â†’3: %dms (expected: ~200ms + execution)          â”‚%n", retryIntervals[2]);
        System.out.println("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");

        // ë‘ ë²ˆì§¸ ê°„ê²©ì´ ì²« ë²ˆì§¸ë³´ë‹¤ ê¸¸ì–´ì•¼ í•¨ (Exponential)
        assertThat(retryIntervals[2])
                .as("ë‘ ë²ˆì§¸ ì¬ì‹œë„ ê°„ê²©ì´ ì²« ë²ˆì§¸ë³´ë‹¤ ê¸¸ì–´ì•¼ í•¨")
                .isGreaterThan(retryIntervals[1]);
    }

    /**
     * ğŸŸ¢ Green's Test 3: ì¥ì•  ë³µêµ¬ í›„ ì¬ì‹œë„ ì„±ê³µ í™•ì¸
     */
    @Test
    @DisplayName("ì¥ì•  ë³µêµ¬ í›„ ì¬ì‹œë„ ì„±ê³µ")
    void shouldSucceed_afterFailureRecovery() throws Exception {
        AtomicInteger attemptCount = new AtomicInteger(0);
        String key = RETRY_STORM_KEY + ":recovery";
        String value = "recovery-value";

        // ì²« ì‹œë„ ì‹œ ì§€ì—°, ì´í›„ ì •ìƒí™”
        ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
        scheduler.schedule(() -> {
            try {
                redisProxy.toxics().get("recovery-latency").remove();
                System.out.println("[Green] Latency removed after 1.5s");
            } catch (Exception ignored) {}
        }, 1500, TimeUnit.MILLISECONDS);

        redisProxy.toxics()
                .latency("recovery-latency", ToxicDirection.DOWNSTREAM, 1000);

        System.out.println("[Green] Starting recovery test with auto-heal after 1.5s");

        boolean success = false;
        int maxRetries = 5;

        while (attemptCount.get() < maxRetries && !success) {
            int attempt = attemptCount.incrementAndGet();
            try {
                CompletableFuture<Void> future = CompletableFuture.runAsync(() ->
                        redisTemplate.opsForValue().set(key, value)
                );
                future.get(500, TimeUnit.MILLISECONDS);
                success = true;
                System.out.printf("[Green] Attempt %d: SUCCESS%n", attempt);
            } catch (Exception e) {
                System.out.printf("[Green] Attempt %d: FAILED%n", attempt);
                Thread.sleep(200L * attempt);
            }
        }

        scheduler.shutdown();

        System.out.println("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”");
        System.out.printf("â”‚ Recovery Test: %s after %d attempts               â”‚%n",
                success ? "SUCCESS" : "FAILED", attemptCount.get());
        System.out.println("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜");

        assertThat(success).as("ì¥ì•  ë³µêµ¬ í›„ ì¬ì‹œë„ ì„±ê³µ").isTrue();
        assertThat(attemptCount.get())
                .as("ì—¬ëŸ¬ ë²ˆì˜ ì¬ì‹œë„ í›„ ì„±ê³µ")
                .isGreaterThan(1);
    }
}
