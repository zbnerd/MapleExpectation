package maple.expectation.global.lock;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import maple.expectation.support.AppIntegrationTestSupport;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIfSystemProperty;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.ContextConfiguration;

/**
 * Redis Lock 일관성 검증 테스트 (Issue #310 Phase 1) - Integration Test Migration
 *
 * <p>Migration from test-legacy to module-infra using SharedContainers singleton pattern.
 *
 * <h3>목적</h3>
 *
 * <p>Dual-Run 기간 동안 Redis와 MySQL 락 간의 데이터 일관성을 검증합니다.
 *
 * <h3>검증 항목</h3>
 *
 * <ul>
 *   <li>Lock Key Collision: 동일 키로 동시 접근 시 정확성
 *   <li>Counter Accuracy: 원자적 증감 연산 정확성
 *   <li>Lock Ordering: 다중 락 순서 보장
 *   <li>Concurrency: 1000 TPS 부하 하에서의 일관성
 * </ul>
 *
 * <h3>실행 방법</h3>
 *
 * <pre>
 * # 일관성 테스트 실행
 * ./gradlew :module-infra:integrationTest --tests "maple.expectation.infra.lock.RedisLockConsistencyTest" \
 *   -Dtest.consistency.enabled=true
 * </pre>
 *
 * @since 2026-02-11
 */
@Tag("integration")
@ActiveProfiles("integrationTest")
@ContextConfiguration(classes = LockTestConfiguration.class)
class RedisLockConsistencyTest extends AppIntegrationTestSupport {

  @Autowired(required = false)
  @Qualifier("redisDistributedLockStrategy") LockStrategy redisLockStrategy;

  @Autowired(required = false)
  StringRedisTemplate redisTemplate;

  @Autowired(required = false)
  LockMetrics lockMetrics;

  private final ExecutorService executorService = Executors.newFixedThreadPool(10);

  @BeforeEach
  void setUp() {
    // 테스트마다 counter 초기화는 Redis flush로 처리됨
    // InfraIntegrationTestSupport @BeforeEach에서 수행
  }

  /**
   * Test 1: Lock Key Collision 검증
   *
   * <p>동일 키로 100개의 스레드가 동시에 락 획득 시도 시 모든 작업이 정확히 순차적으로 실행되는지 검증
   */
  @Test
  @EnabledIfSystemProperty(
      named = "test.consistency.enabled",
      matches = "true",
      disabledReason = "Consistency test requires explicit activation")
  void testLockKeyCollision_NoRaceCondition() throws Exception {
    // Given
    String lockKey = "test:consistency:collision";
    AtomicInteger counter = new AtomicInteger(0);
    int threadCount = 100;
    CountDownLatch latch = new CountDownLatch(threadCount);

    // When - 100개 스레드가 동시에 락 획득 및 카운터 증가
    List<Future<Integer>> futures = new ArrayList<>();
    for (int i = 0; i < threadCount; i++) {
      Future<Integer> future =
          executorService.submit(
              () -> {
                try {
                  return redisLockStrategy.executeWithLock(
                      lockKey,
                      10,
                      30,
                      () -> {
                        int value = counter.incrementAndGet();
                        Thread.sleep(10); // 작업 시뮬레이션
                        return value;
                      });
                } catch (Throwable t) {
                  throw new RuntimeException(t);
                } finally {
                  latch.countDown();
                }
              });
      futures.add(future);
    }

    // Then - 모든 작업 완료 대기
    boolean completed = latch.await(30, TimeUnit.SECONDS);
    assertThat(completed).isTrue();

    // 모든 결과가 1~100 사이의 고유한 값이어야 함
    List<Integer> results = new ArrayList<>();
    for (Future<Integer> future : futures) {
      results.add(future.get());
    }

    assertThat(results).hasSize(threadCount);
    assertThat(results).doesNotHaveDuplicates();
    assertThat(counter.get()).isEqualTo(threadCount);

    // 메트릭 검증 (선택사항)
    if (lockMetrics != null) {
      long activeLocks = lockMetrics.getActiveLocks("redis");
      assertThat(activeLocks).isLessThanOrEqualTo(1); // 최대 1개의 활성 락
    }
  }

  /**
   * Test 2: Counter Accuracy 검증
   *
   * <p>분산 환경에서 카운터 연산의 정확성을 검증
   */
  @Test
  @EnabledIfSystemProperty(named = "test.consistency.enabled", matches = "true")
  void testCounterAccuracy_ExactlyOnce() throws Exception {
    // Given
    String lockKey = "test:consistency:counter";
    AtomicInteger counter = new AtomicInteger(0);
    int increments = 1000;

    // When - 1000번의 증가 연산
    for (int i = 0; i < increments; i++) {
      final int iteration = i;
      executorService.submit(
          () -> {
            try {
              redisLockStrategy.executeWithLock(
                  lockKey,
                  5,
                  10,
                  () -> {
                    counter.incrementAndGet();
                    return null;
                  });
            } catch (Throwable t) {
              throw new RuntimeException(t);
            }
          });
    }

    // 작업 완료 대기
    Thread.sleep(5000);

    // Then - 카운터가 정확히 1000이어야 함
    assertThat(counter.get()).isEqualTo(increments);
  }

  /**
   * Test 3: Lock Ordering 일관성
   *
   * <p>다중 락을 알파벳순으로 획득 시 Deadlock 방지 검증
   */
  @Test
  @EnabledIfSystemProperty(named = "test.consistency.enabled", matches = "true")
  void testLockOrdering_NoDeadlock() throws Throwable {
    // Given - 알파벳순이 아닌 키들
    String keyZ = "test:lock:zulu";
    String keyA = "test:lock:alpha";
    String keyM = "test:lock:medium";

    AtomicInteger executionCount = new AtomicInteger(0);
    int threadCount = 10;
    CountDownLatch latch = new CountDownLatch(threadCount);

    // When - 10개 스레드가 무작위 순서로 다중 락 획득 시도
    for (int i = 0; i < threadCount; i++) {
      executorService.submit(
          () -> {
            try {
              // 순서 보장 다중 락 실행
              redisLockStrategy.executeWithOrderedLocks(
                  List.of(keyZ, keyA, keyM),
                  10,
                  TimeUnit.SECONDS,
                  30,
                  () -> {
                    executionCount.incrementAndGet();
                    Thread.sleep(50);
                    return "completed";
                  });
            } catch (Throwable e) {
              throw new RuntimeException(e);
            } finally {
              latch.countDown();
            }
          });
    }

    // Then - 모든 스레드가 성공적으로 완료 (Deadlock 없음)
    boolean completed = latch.await(60, TimeUnit.SECONDS);
    assertThat(completed).isTrue();
    assertThat(executionCount.get()).isEqualTo(threadCount);
  }

  /**
   * Test 4: Redis 락 일관성 검증
   *
   * <p>Redis 락이 동일한 작업에 대해 일관성 있게 동작하는지 검증
   */
  @Test
  @EnabledIfSystemProperty(named = "test.consistency.enabled", matches = "true")
  void testRedisLockResult_Consistency() throws Exception {
    // Given
    String lockKey = "test:consistency:redis";
    AtomicInteger sharedCounter = new AtomicInteger(0);
    int operations = 100;

    // When - Redis 락으로 100번 실행
    List<Integer> redisResults = new CopyOnWriteArrayList<>();
    for (int i = 0; i < operations; i++) {
      int result =
          redisLockStrategy.executeWithLock(
              lockKey,
              5,
              10,
              () -> {
                return sharedCounter.incrementAndGet();
              });
      redisResults.add(result);
    }

    // Then - Redis 결과 검증
    assertThat(redisResults).hasSize(operations);
    assertThat(redisResults.get(0)).isEqualTo(1);
    assertThat(redisResults.get(operations - 1)).isEqualTo(operations);

    // 전체 카운터 검증
    assertThat(sharedCounter.get()).isEqualTo(operations);
  }

  /**
   * Test 5: 고부하 상황에서의 일관성 (1000 TPS)
   *
   * <p>초당 1000건의 요청을 5초간 처리하여 일관성 검증
   */
  @Test
  @EnabledIfSystemProperty(named = "test.consistency.enabled", matches = "true")
  void testHighLoadConsistency_1000TPS() throws Exception {
    // Given
    String lockKey = "test:consistency:highload";
    AtomicInteger counter = new AtomicInteger(0);
    AtomicInteger errors = new AtomicInteger(0);

    int targetTPS = 1000;
    int durationSeconds = 5;
    int totalOperations = targetTPS * durationSeconds;

    ExecutorService highLoadExecutor = Executors.newFixedThreadPool(50);
    CountDownLatch latch = new CountDownLatch(totalOperations);

    // When - 1000 TPS로 5초간 부하
    long startTime = System.currentTimeMillis();
    for (int i = 0; i < totalOperations; i++) {
      highLoadExecutor.submit(
          () -> {
            try {
              redisLockStrategy.executeWithLock(
                  lockKey,
                  10,
                  30,
                  () -> {
                    counter.incrementAndGet();
                    return null;
                  });
            } catch (Exception e) {
              errors.incrementAndGet();
            } finally {
              latch.countDown();
            }
          });
    }

    // Then - 모든 작업 완료 대기
    boolean completed = latch.await(30, TimeUnit.SECONDS);
    long endTime = System.currentTimeMillis();
    long actualDuration = endTime - startTime;

    assertThat(completed).isTrue();
    assertThat(errors.get()).isEqualTo(0);
    assertThat(counter.get()).isEqualTo(totalOperations);

    // 성능 검증 (평균 10ms 미만 권장)
    double avgLatencyMs = (double) actualDuration / totalOperations;
    assertThat(avgLatencyMs).isLessThan(10.0); // 10ms 미만

    highLoadExecutor.shutdown();
  }

  /**
   * Test 6: Lock Key Hash Tag 분산 검증
   *
   * <p>Redis Cluster 환경에서 Hash Tag가 동일 슬롯을 보장하는지 검증
   */
  @Test
  @EnabledIfSystemProperty(named = "test.consistency.enabled", matches = "true")
  void testHashTagDistribution_SameSlot() throws Throwable {
    // Given - Hash Tag가 포함된 키
    String key1 = "{user:123}:lock:operation1";
    String key2 = "{user:123}:lock:operation2";
    String key3 = "{user:123}:lock:operation3";

    // When - 동일한 Hash Tag를 사용하는 다중 락 실행
    AtomicInteger executionCount = new AtomicInteger(0);

    try {
      redisLockStrategy.executeWithOrderedLocks(
          List.of(key1, key2, key3),
          10,
          TimeUnit.SECONDS,
          30,
          () -> {
            executionCount.incrementAndGet();
            return "completed";
          });

      // Then - 성공적으로 완료 (Hash Tag로 인해 동일 슬롯 사용)
      assertThat(executionCount.get()).isEqualTo(1);
    } catch (Exception e) {
      // Redis Cluster 미설정 환경에서는 Skip 허용
      assertThat(e).isInstanceOf(Exception.class);
    }
  }
}
