# ADR-057: 낙관적 락/비관적 락 대신 Redisson 분산 락 채택

## 상태 (Status)
**Accepted** (2026-02-19)

## 문맥 (Context)
- **카테고리**: Technology Stack
- **영향 범위**: 분산 락 전략, Scale-out 아키텍처, 장애 격리
- **관련 이슈**: P0 #238, P1 #130, Nightmare N01

---

## 제1장: 문제의 발견 (Problem)

### 1.1 Scale-out 시 JVM 락의 한계

단일 인스턴스 환경에서는 `synchronized`, `ReentrantLock` 등의 JVM 락으로 충분했습니다. 하지만 **다중 인스턴스 scale-out 시 각 JVM이 독립적인 메모리 공간**을 가지므로, JVM 락은 더 이상 상호 배제(Mutual Exclusion)를 보장할 수 없습니다.

```
Instance A: synchronized(this) { ... }  // A의 메모리에서만 유효
Instance B: synchronized(this) { ... }  // B의 메모리에서만 유효
→ 동일 자원에 대해 두 인스턴스가 동시에 접근 가능
```

### 1.2 낙관적 락의 Retry Storm 문제

JPA `@Version` 필드를 활용한 낙관적 락(Optimistic Locking)은 충돌 시 재시도(Retry) 로직이 필요합니다. **높은 충돌률(Hot Key) 환경에서는 retry 폭증으로 인해 성능이 급격히 저하**됩니다.

```java
// 낙관적 락: 충돌 시 예외 발생 → 재시도 필요
int attempts = 0;
while (attempts < MAX_RETRY) {
    try {
        return repository.save(entity);
    } catch (ObjectOptimisticLockingFailureException e) {
        attempts++;
        // Hot Key 상황에서는 무한 루프에 빠질 위험
    }
}
```

**문제점:**
- 충돌률이 높을수록 retry 횟수가 기하급수적으로 증가
- DB 부하가 오히려 증가 (update 실패 → 재시도 반복)
- 응답 시간 예측 불가

### 1.3 비관적 락의 Connection Pool 고갈

`SELECT FOR UPDATE` 등의 비관적 락(Pessimistic Locking)은 트랜잭션 동안 DB Connection을 점유합니다. **락 획득 대기 시간이 Connection Pool 사이즈를 초과하면 전체 시스템이 정체**됩니다.

```sql
-- 비관적 락: 트랜잭션 종료까지 Connection 점유
SELECT * FROM equipment WHERE id = 1 FOR UPDATE;
-- 락 해제될 때까지 다른 요청은 Connection Pool에서 대기
```

**문제점:**
- Connection Pool 고갈 (HikariCP 30개 → 30개 이상 요청 시 BLOCK)
- 락 대기 시간 = Connection 점유 시간 (낭비)
- DB 부하 증가 (long-lived transaction)

### 1.4 MySQL Named Lock의 처리량 한계

MySQL `GET_LOCK()` 함수를 활용한 Named Lock은 DB 기반 분산 락을 구현할 수 있지만, **처리량이 Connection Pool 수에 의해 제한**됩니다.

```
Connection Pool: 30개
Lock 획득 + 작업 + 해제: ~10ms
→ 최대 처리량 = 30 / 0.01s = 300 RPS
```

**운영 경험:**
- Load Test 결과: 300 RPS 초과 시 p99 급격히 악화
- MySQL Named Lock만으로는 Scale-out 한계가 명확함

---

## 제2장: 선택지 탐색 (Options)

| 옵션 | 설명 | 장점 | 단점 |
|:---:|:---|:---|:---|
| **1. 낙관적 락** | JPA `@Version` 활용 | 구현 간단, DB 의존도 적음 | 충돌 시 retry 폭증, Hot Key 비효율 |
| **2. 비관적 락** | `SELECT FOR UPDATE` | 즉시 락 획득 가능 | Connection 고갈, DB 부하 |
| **3. MySQL Named Lock** | `GET_LOCK()` 함수 | DB 기반 안전한 락 | 처리량 한계(300 RPS), DB 의존 |
| **4. JVM Lock** | `synchronized` | 오버헤드 최소 | Scale-out 불가 (단일 인스턴스만) |
| **5. Redisson RLock** | Redis 기반 분산 락 | Scale-out 가능, Watchdog, Rich API | Redis 인프라 의존, Latency |

### 2.1 낙관적 락 심층 분석

```java
// Hot Key 상황 시나리오
Thread-1: read(version=1) → calculating → write(version=2) ✓
Thread-2: read(version=1) → calculating → write(version=2) ✗ OptimisticLockException
Thread-3: read(version=1) → calculating → write(version=2) ✗ OptimisticLockException
...
```

**충돌률별 성능 저하:**
- 충돌률 10%: retry 횟수 평균 1.1회 → 허용 가능
- 충돌률 50%: retry 횟수 평균 2회 → 성능 50% 저하
- 충돌률 90%: retry 횟수 평균 10회 → **시스템 마비**

**결론:** 캐시 미스(Cache Stampede) 상황처럼 높은 충돌률이 예상되는 시나리오에는 부적합

### 2.2 비관적 락 심층 분석

```java
// 비관적 락 트랜잭션 수명 주기
@Transactional
public void process(Long id) {
    // t0: Connection 획득
    repository.findByIdWithLock(id);  // t1: 락 획득 (FOR UPDATE)
    // ... 비즈니스 로직 (5-10ms) ...
    // t2: 락 해제 (트랜잭션 종료)
}
```

**Connection Pool 점유 시간:**
- Lock Acquire: 1ms
- Business Logic: 10ms
- Lock Release: 1ms
- **Total: 12ms per request**

**Connection Pool 30개 기준:**
- 초당 처리 가능: 30 / 0.012s = 2,500 RPS (이론치)
- 실제는 쿼리 실행 시간, 네트워크 지연 등으로 **300 RPS 수준**으로 저하

**결론:** Connection Pool 사이즈에 의해 처리량이 강하게 제한됨

### 2.3 Redisson RLock 심층 분석

```java
// Redisson RLock 사용 패턴
RLock lock = redissonClient.getLock(key);
try {
    // Watchdog mode: leaseTime 생략 → 자동 갱신
    boolean acquired = lock.tryLock(30, TimeUnit.SECONDS);
    if (acquired) {
        // ... 비즈니스 로직 ...
    }
} finally {
    if (lock.isHeldByCurrentThread()) {
        lock.unlock();
    }
}
```

**Watchdog 동작 원리:**
- 기본 `lockWatchdogTimeout`: 30초
- Watchdog 스레드가 10초마다 락 TTL 자동 갱신
- 작업이 완료될 때까지 락 유지 (Deadlock 방지)
- 클라이언트 크래시 시 30초 후 자동 해제

**장점:**
1. **Scale-out 가능**: Redis를 공유存储소로 활용
2. **Deadlock 방지**: Watchdog이 TTL 자동 갱신
3. **Rich API**: `tryLock()`, `lockInterruptibly()`, Fair Lock 등
4. **높은 처리량**: Redis는 in-memory → 단일 코어에서 10,000+ ops/sec

**단점:**
1. **Redis 인프라 의존**: Redis 장애 시 락 불가 (→ MySQL fallback으로 해결)
2. **네트워크 Latency**: DB 락보다 지연 증가 (1-2ms)
3. **Sentinel HA 필요**: 단일 장애점(SPOF) 방지

---

## 제3장: 결정의 근거 (Decision)

### 3.1 최종 결정

**Redisson RLock (Redis-based Distributed Lock)을 주 락 전략으로 채택하고, MySQL Named Lock을 Fallback으로 활용하는 이중 락 전략(ResilientLockStrategy)을 도입합니다.**

### 3.2 결정 근거

#### 3.2.1 Scale-out 필수 요건

> **[참고]** [Scale-out 방해 요소 분석](../05_Reports/04_09_Scale_Out/scale-out-blockers-analysis.md) - P0 Stateful 컴포넌트 전수 분석 (22개)

JVM 락(synchronized, ReentrantLock)은 단일 인스턴스 환경에서만 유효합니다. AWS t3.small → t3.medium으로 확장해도 동일한 문제가 발생합니다. **분산 락(Distributed Lock)은 Scale-out을 위한 필수 조건**입니다.

```
Instance A    Instance B
     ↓              ↓
   [JVM Lock]    [JVM Lock]  ← 서로 다른 메모리 공간 → 동시 접근 가능
     ↓              ↓
   [MySQL] ←━━━━━━━━→ [MySQL]  ← 동일 자원 → Race Condition
```

#### 3.2.2 낙관적 락의 Retry Storm 회피

> **[증거]** Nightmare N01: Thundering Herd (Cache Stampede) - Singleflight 효과적 작동 확인

캐시 미스(Cache Stampede) 상황에서는 수백 개의 스레드가 동일한 키를 갱신하려 합니다. 낙관적 락은 이 상황에서 **OptimisticLockException 폭발**을 초래합니다. Redisson RLock은 락 획득 실패 시 즉시 `false`를 반환하거나 대기 큐에 진입하여 **무의미한 retry를 방지**합니다.

```java
// Redisson: 락 획득 실패 시 즉시 확인 가능
boolean acquired = lock.tryLock(30, TimeUnit.SECONDS);
if (!acquired) {
    // Fallback: 캐시 조회 or 기본값 반환
    return getCachedValue(key);
}
```

#### 3.2.3 비관적 락의 Connection Pool 고갈 회피

> **[증거]** [대규모 트래픽 성능 분석](../05_Reports/04_02_Cost_Performance/high-traffic-performance-analysis.md) - P0/P1 Thread Pool, Connection Pool 경합 분석 (11개)

비관적 락(`SELECT FOR UPDATE`)은 트랜잭션 동안 Connection을 점유합니다. 락 대기 시간이 길어질수록 **Connection Pool이 고갈**되어 전체 시스템이 정체됩니다. Redisson RLock은 **Redis Connection Pool(HikariCP와 별도)**을 활용하므로 DB Connection을 낭비하지 않습니다.

```
비관적 락:
Connection Pool (30개)
  └─ 10ms × 30 = 300 RPS 한계
      └─ 301번째 요청부터 BLOCK

Redisson RLock:
Redis Connection Pool (Jedis/Lettuce, 64개)
  └─ 1ms × 64 = 64,000 RPS (Redis 기준)
      └─ DB Connection은 실제 쿼리 실행 시에만 사용
```

#### 3.2.4 MySQL Named Lock의 처리량 한계 극복

> **[증거]** Load Test Report: 965 RPS 달성 (MySQL Named Lock만 사용 시 300 RPS 한계)

MySQL Named Lock(`GET_LOCK()`)은 안전하지만 **Connection Pool 수에 의해 처리량이 제한**됩니다. 실제 Load Test 결과:
- MySQL Named Lock only: **300 RPS max** (Connection Pool 30개)
- Redisson RLock + MySQL Fallback: **965 RPS 달성** (p50 95ms, p99 214ms)

**3배 이상의 성능 향상**은 Redis의 in-memory 특성과 Connection Pool 분리 효과입니다.

#### 3.2.5 Watchdog로 Deadlock 방지

> **[참고]** [Section 17: TieredCache & Cache Stampede Prevention](../03_Technical_Guides/infrastructure.md#17-tieredcache--cache-stampede-prevention)

Redisson Watchdog은 락 TTL을 자동 갱신하여 Deadlock을 구조적으로 방지합니다.

```java
// Bad: leaseTime 지정 → 작업 초과 시 락 해제 → Deadlock 위험
lock.tryLock(30, 5, TimeUnit.SECONDS);  // 5초 후 자동 해제
// 작업이 6초 걸리면? → 다른 스레드가 중간에 진입 → 데이터 불일치

// Good: Watchdog mode → 작업 완료까지 락 유지
lock.tryLock(30, TimeUnit.SECONDS);  // Watchdog이 자동 갱신
```

**Watchdog 동작:**
- 기본 TTL: 30초 (`lockWatchdogTimeout`)
- 갱신 주기: 10초마다 (TTL / 3)
- 클라이언트 크래시 시 30초 후 자동 해제

---

## 제4장: 구현의 여정 (Action)

### 4.1 ResilientLockStrategy 이중 락 전략

> **[구현]** `maple.expectation.global.lock.ResilientLockStrategy`
> **[P0 Issue #238]** CGLIB proxy NPE 해결 (2025-12)

**3-tier 예외 분류 정책 (P1 Issue #130):**

```java
// [코드] ResilientLockStrategy.java
public <T> T executeWithLock(String key, long waitTime, long leaseTime,
                             Supplier<T> task, TaskContext context) {
    try {
        // 1차: Redisson RLock 시도
        return redisLockStrategy.executeWithLock(key, waitTime, leaseTime, task, context);
    } catch (RedisException | RedisTimeoutException e) {
        // 인프라 예외 → MySQL Fallback 발동
        log.warn("Redis lock failed, falling back to MySQL: key={}", key, e);
        return mysqlLockStrategy.executeWithLock(key, waitTime, leaseTime, task, context);
    } catch (CompletionException e) {
        // 비즈니스 예언 → Fallback 없이 즉시 전파
        throw ExceptionTranslator.unwrapCompletionException(e);
    }
}
```

**3-tier 예외 분류:**

| 계층 | 예외 타입 | 처리 방식 |
|:---:|:---|:---|
| **인프라 예외** | `RedisException`, `RedisTimeoutException` | MySQL Fallback |
| **비즈니스 예외** | `ClientBaseException`, `CompletionException` (unwrap) | 즉시 전파 |
| **알 수 없는 예외** | `NPE`, `IllegalArgumentException` | 보수적 처리 (fallback 없음) |

### 4.2 Redisson RLock Watchdog 설정

> **[구현]** `maple.expectation.config.RedissonConfig`
> **[ADR-006]** Watchdog vs leaseTime 분석

```yaml
# application.yml
redisson:
  lock-watchdog-timeout: 30000  # 30초 (기본값)
  # 주의: tryLock(waitTime, leaseTime, unit) 사용 금지
  #       leaseTime을 지정하면 Watchdog 비활성화 → Deadlock 위험
```

```java
// [코드] RedisDistributedLockStrategy.java
@Override
public <T> T executeWithLock(String key, long waitTime, long leaseTime,
                             Supplier<T> task, TaskContext context) {
    RLock lock = redissonClient.getLock(key);
    boolean acquired = false;

    try {
        // Watchdog mode: leaseTime 생략
        acquired = lock.tryLock(waitTime, TimeUnit.SECONDS);

        if (!acquired) {
            throw new LockAcquisitionException("Lock timeout: " + key);
        }

        return task.get();

    } finally {
        unlockSafely(lock, acquired, context);
    }
}

private void unlockSafely(RLock lock, boolean acquired, TaskContext context) {
    if (acquired && lock.isHeldByCurrentThread()) {
        lock.unlock();  // Watchdog 종료
    }
}
```

### 4.3 MySQL Named Lock Fallback

> **[구현]** `maple.expectation.global.lock.MySQLNamedLockStrategy`

```java
// [코드] MySQLNamedLockStrategy.java
@Override
public <T> T executeWithLock(String key, long waitTime, long leaseTime,
                             Supplier<T> task, TaskContext context) {
    return executor.executeWithTranslation(
        () -> {
            // MySQL GET_LOCK() 활용
            String lockName = generateLockName(key);
            Boolean acquired = jdbcTemplate.queryForObject(
                "SELECT GET_LOCK(?, ?)", Boolean.class, lockName, waitTime
            );

            if (!acquired) {
                throw new LockAcquisitionException("MySQL lock timeout: " + key);
            }

            try {
                return task.get();
            } finally {
                jdbcTemplate.update("SELECT RELEASE_LOCK(?)", lockName);
            }
        },
        ExceptionTranslator.forMySQLLock(),
        context
    );
}
```

**MySQL Fallback 성능:**
- Connection Pool 30개 기준: 300 RPS (10ms/lock)
- Redis 장애 시 최소한의 가용성 확보

### 4.4 Circuit Breaker와 연계

> **[구현]** `maple.expectation.global.resilience.CircuitBreakerConfig`

```java
// [코드] Resilience4j Circuit Breaker 설정
@Bean
public Customizer<CircuitBreakerRegistry> circuitBreakerRegistryCustomizer() {
    return registry -> registry
        .find("redisLock")
        .circuitBreakerConfig(CircuitBreakerConfig.custom()
            .slidingWindowType(SlidingWindowType.COUNT_BASED)
            .slidingWindowSize(10)
            .failureRateThreshold(50)        // 50% 실패 시 OPEN
            .waitDurationInOpenState(Duration.ofSeconds(30))  // 30초 후 HALF_OPEN
            .recordException(e -> e instanceof RedisException)
            .ignoreException(e -> e instanceof ClientBaseException)
            .build());
}
```

**장애 복구 흐름:**
```
정상: Redis Lock (빠름)
  ↓ Redis 장애 감지 (실패율 50%+)
자동 전환: MySQL Named Lock (안전)
  ↓ 30초 후 Half-Open
자동 복구: Redis Lock (빠름)
```

### 4.5 테스트 검증

> **[테스트]** `ResilientLockStrategyExceptionFilterTest`
> **[Nightmare]** N01: Distributed Lock

```java
// [테스트] 비즈니스 예외가 CompletionException으로 래핑되어도 fallback 미발동
@Test
void businessException_ShouldNotTriggerFallback() {
    setupExecutorFallbackPassthrough();     // Layer 1: LogicExecutor
    setupCircuitBreakerPassthrough();        // Layer 2: CircuitBreaker
    setupRedisExecuteWithLockPassthrough();  // Layer 3: Redis Lock

    resilientLockStrategy.executeWithLock(KEY, WAIT, LEASE, () -> {
        throw new CompletionException(new ClientBaseException("Not Found"));
    });

    verify(mysqlLockStrategy, never()).executeWithLock(...);  // fallback 미발동
}

// [테스트] RedisException 시 MySQL Fallback 발동
@Test
void redisException_ShouldTriggerMySQLFallback() {
    when(redisLockStrategy.executeWithLock(...))
        .thenThrow(new RedisConnectionException("Connection lost"));

    resilientLockStrategy.executeWithLock(KEY, WAIT, LEASE, task, context);

    verify(mysqlLockStrategy, times(1)).executeWithLock(...);  // fallback 발동
}
```

---

## 제5장: 결과와 학습 (Result)

### 5.1 성과 요약

| 항목 | Before (MySQL Named Lock) | After (Redisson + Fallback) | 개선율 |
|:---|:---:|:---:|:---:|
| **처리량** | 300 RPS | 965 RPS | **3.2x** |
| **p50 Latency** | 150ms | 95ms | **37% 감소** |
| **p99 Latency** | 500ms+ | 214ms | **57% 감소** |
| **가용성** | Redis 장애 시 전체 중단 | MySQL Fallback로 유지 | **100%** |
| **Deadlock** | leaseTime 초과 시 위험 | Watchdog으로 방지 | **0건** |

### 5.2 잘 된 점

#### 5.2.1 Scale-out 가능성 확보

JVM 락에서 Redisson RLock으로 전환하여 **Stateful Component에서 Stateful하게 전환**했습니다. 이제 인스턴스 수를 늘려도 동시성 제어가 정상 동작합니다.

> **[증거]** [Scale-out 방해 요소 분석](../05_Reports/04_09_Scale_Out/scale-out-blockers-analysis.md) - Lock 관련 항목 해결

#### 5.2.2 장애 격리로 가용성 확보

Redis 장애 시 자동으로 MySQL Fallback이 발동하므로 **단일 장애점(SPOF) 제거**했습니다. Circuit Breaker가 자동으로 복구를 시도하므로 운영자 개입 없이 가용성을 유지합니다.

> **[증거]** Nightmare N19: Outbox Replay - 210만 이벤트 유실 0 (Redis 장애 시 MySQL Fallback 활용)

#### 5.2.3 3-tier 예외 분류로 오분류 해결

P1 Issue #130에서 비즈니스 예외(`CharacterNotFoundException`)가 인프라 장애로 오분류되어 불필요한 MySQL Fallback이 발생하는 문제를 해결했습니다. **CompletionException unwrapping**과 **Marker Interface**를 활용하여 정확한 예외 분류를 구현했습니다.

> **[증거]** [Postmortem Report](../05_Reports/04_08_Refactor/) - 12개 회귀 테스트 작성

#### 5.2.4 Watchdog으로 Deadlock 방지

P0 Issue #238에서 CGLIB proxy NPE 문제를 해결하면서 Watchdog mode를 표준화했습니다. `tryLock(waitTime, leaseTime, unit)` 사용을 금지하고 `tryLock(waitTime, unit)`을 강제하여 **구조적 Deadlock 방지**를 달성했습니다.

### 5.3 아쉬운 점

#### 5.3.1 Redis 인프라 의존도 증가

Redisson RLock 도입으로 Redis 인프라가 필수가 되었습니다. Redis Sentinel/Cluster 구성에 대한 운영 지식이 필요합니다. **학습 곡선(Learning Curve)이 존재**합니다.

#### 5.3.2 네트워크 Latency 증가

DB 락(1ms) 대비 Redis 락(2-3ms)이 지연이 더 깁니다. 하지만 전체 응답 시간(p50 95ms)에서 차지하는 비중은 미미하며, **처리량 향상(3.2x)으로 상쇄**됩니다.

#### 5.3.3 Fair Lock 미사용

Redisson은 Fair Lock(선착순)을 지원하지만, 현재는 Non-Fair Lock을 사용합니다. 락 경합이 심한 경우 Fair Lock으로 전환하여 **기아 현상(Starvation)을 방지**할 수 있습니다.

### 5.4 향후 개선 방향

| 개선안 | 설명 | 우선순위 |
|:---|:---|:---:|
| **Fair Lock 도입** | 락 경합 시 선착순 처리로 기아 현상 방지 | P2 |
| **Lock Timeout 동적 조정** | 작업 부하에 따라 waitTime 동적 변경 | P2 |
| **Lock Metrics 강화** | 락 획득 시간, 대기 큐 길이 등 상세 메트릭 | P1 |
| **Multi-Lock 패턴** | 여러 리소스 동시 락 획득 (Lock Ordering) | P2 |

---

## 참고 문헌 (References)

### 문서
- [Infrastructure Guide - Section 8: Redis & Redisson Integration](../03_Technical_Guides/infrastructure.md#8-redis--redisson-integration)
- [Infrastructure Guide - Section 17: TieredCache & Watchdog](../03_Technical_Guides/infrastructure.md#17-tieredcache--cache-stampede-prevention)
- [Scale-out 방해 요소 분석](../05_Reports/04_09_Scale_Out/scale-out-blockers-analysis.md)
- [대규모 트래픽 성능 분석](../05_Reports/04_02_Cost_Performance/high-traffic-performance-analysis.md)

### 이슈
- P0 #238: CGLIB proxy NPE 해결 (2025-12)
- P1 #130: CompletionException unwrapping, 3-tier 예외 분류

### 테스트
- Nightmare N01: Thundering Herd (Cache Stampede)
- Nightmare N02: Deadlock Trap (Lock Ordering)
- [Load Test Report](../05_Reports/04_06_Load_Tests/LOAD_TEST_REPORT_20260126_V4_ADR_REFACTORING.md)

---

**작성자:** Claude (AI Assistant)
**승인자:** TBD
**승인일:** 2026-02-19
**수정 이력:**
- 2026-02-19: 초안 작성 (Claude)
