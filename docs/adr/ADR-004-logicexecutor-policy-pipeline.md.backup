# ADR-004: LogicExecutor 및 Policy Pipeline 아키텍처

## 상태
Accepted

## 문서 무결성 체크리스트

### 1. 기본 정보
| # | 항목 | 상태 | 비고 |
|---|------|------|------|
| 1 | 의사결정 날짜 | ✅ | 2025-11-15 (PR #266) |
| 2 | 결정자 | ✅ | Blue Agent (Architecture) |
| 3 | 관련 Issue/PR | ✅ | #266 Load Test 719 RPS |
| 4 | 상태 | ✅ | Accepted & Implemented |
| 5 | 최종 업데이트 | ✅ | 2026-02-05 |

### 2. 맥락 및 문제
| # | 항목 | 상태 | 비고 |
|---|-----------|------|------|
| 6 | 비즈니스 문제 | ✅ | try-catch 패턴 불일치, 로깅 누락 |
| 7 | 기술적 문제 | ✅ | RuntimeException 래핑 난립 |
| 8 | 성능 수치 | ✅ | RPS 719, 0% Error Rate |
| 9 | 영향도 | ✅ | 코드 가독성, 유지보수성 |
| 10 | 선행 조건 | ✅ | Spring Boot 3.x, Java 21 |

### 3. 대안 분석
| # | 항목 | 상태 | 비고 |
|---|-----------|------|------|
| 11 | 최소 3개 대안 | ✅ | AOP, 표준화, LogicExecutor |
| 12 | 장단점 비교 | ✅ | 표로 정리 |
| 13 | 거절 근거 | ✅ | "유연성 부족", "강제력 없음" |
| 14 | 채택 근거 | ✅ | 8가지 패턴, 컴파일 타임 강제 |
| 15 | 트레이드오프 | ✅ | 학습 곡선 vs 일관성 |

### 4. 결정 및 증거
| # | 항목 | 상태 | 비고 |
|---|-----------|------|------|
| 16 | 구현 결정 | ✅ | LogicExecutor + Policy Pipeline |
| 17 | Evidence ID | ✅ | [E1], [C1], [P1] |
| 18 | 코드 참조 | ✅ | 실제 클래스 확인 |
| 19 | 성능 수치 | ✅ | 예외 처리 일관성 100% |
| 20 | 부작용 | ✅ | 람다 중첩 (섹션 15 해결) |

### 5. 실행 및 검증
| # | 항목 | 상태 | 비고 |
|---|-----------|------|------|
| 21 | 구현 클래스 | ✅ | `LogicExecutor`, `ExecutionPipeline` |
| 22 | 재현성 명령어 | ✅ | 부하테스트 #266 |
| 23 | 롤백 계획 | ✅ | try-catch로 수동 복원 |
| 24 | 모니터링 | ✅ | TaskContext 기반 메트릭 |
| 25 | 테스트 커버리지 | ✅ | `LogicExecutorTest` |

### 6. 유지보수
| # | 항목 | 상태 | 비고 |
|---|-----------|------|------|
| 26 | 관련 ADR | ✅ | 모든 ADR이 LogicExecutor 사용 |
| 27 | 만료일 | ✅ | 없음 (핵심 패턴) |
| 28 | 재검토 트리거 | ✅ | 예외 처리 누락 10건 이상 |
| 29 | 버전 호환성 | ✅ | Java 21+ Record |
| 30 | 의존성 변경 | ✅ | Spring Framework 6.x |

---

## Fail If Wrong

1. **[F1]** try-catch 블록이 service/ 패키지에 5건 이상 발견됨
2. **[F2]** RuntimeException 래핑이 10건 이상 발생
3. **[F3]** TaskContext 카디널리티 폭발 (> 10,000 tags)
4. **[F4]** ExecutionPipeline 순서 보장 실패 (BEFORE/AFTER 불일치)

---

## Terminology

| 용어 | 정의 |
|------|------|
| **LogicExecutor** | 예외 처리, 로깅, 메트릭을 표준화하는 템플릿 패턴 |
| **TaskContext** | 컴포넌트, 오퍼레이션, 동적 값으로 구조화된 컨텍스트 |
| **ExecutionPipeline** | Policy 체인으로 BEFORE/AFTER/ON_SUCCESS/ON_FAILURE 수행 |
| **Policy** | Logging, Metrics, CircuitBreaker 등의 횡단 관심사 |
| **Lambda Hell** | 과도한 람다 중첩으로 가독성 저하 (CLAUDE.md 섹션 15) |

---

## 맥락 (Context)

### 문제 정의

비즈니스 로직 전반에 산재한 try-catch 블록이 다음 문제를 야기했습니다:

**관찰된 문제:**
- 예외 처리 패턴 불일치 (개발자별 스타일 차이) [E1]
- 로깅/메트릭 수집 누락 (수동으로 작성 시 실수) [E2]
- 체크 예외의 RuntimeException 래핑 난립 [E3]
- 리소스 해제 로직 누락 (finally 블록 실수) [E4]

**부하테스트 결과 (#266):**
- RPS 719 달성 시 일관된 예외 처리가 핵심 [P1]
- 0% Error Rate 유지를 위한 표준화된 복구 패턴 필요 [P2]

## 검토한 대안 (Options Considered)

### 옵션 A: AOP 기반 예외 처리
```java
@Around("@annotation(ExceptionHandled)")
public Object handleException(ProceedingJoinPoint pjp) {
    try { return pjp.proceed(); }
    catch (Exception e) { ... }
}
```
- **장점:** 비침투적, 선언적
- **단점:** 세밀한 복구 로직 불가, 컨텍스트 전달 어려움
- **거절 근거:** [R1] 각 예외 타입별 다른 복구 로직 구현 불가
- **결론:** 유연성 부족 (기각)

### 옵션 B: 직접 try-catch 표준화
```java
// 코딩 컨벤션으로 강제
try {
    return repository.findById(id);
} catch (Exception e) {
    log.error("[Domain:FindById] {}", e.getMessage());
    return null;
}
```
- **장점:** 즉시 적용 가능
- **단점:** 강제력 없음, 보일러플레이트 증가
- **거절 근거:** [R2] Code Review에서 누락 발견, 개인마다 스타일 차이
- **결론:** 일관성 보장 불가 (기각)

### 옵션 C: LogicExecutor + Policy Pipeline
- **장점:** 8가지 표준 패턴, 컴파일 타임 강제, 메트릭 자동 수집
- **단점:** 학습 곡선, 람다 중첩 위험
- **채택 근거:** [C1] 100% 표준화 달성, CLAUDE.md 섹션 15로 Lambda Hell 해결
- **결론:** 채택

### Trade-off Analysis

| 평가 기준 | AOP | 표준화 try-catch | LogicExecutor | 비고 |
|-----------|-----|------------------|---------------|------|
| **일관성 보장** | Low | Low | **100%** | C 승 |
| **복구 로직 유연성** | Low | High | **High** | B/C 승 |
| **컴파일 타임 체크** | No | No | **Yes** | C 승 |
| **메트릭 자동 수집** | Medium | Low | **High** | C 승 |
| **학습 곡선** | Low | Low | Medium | A/B 승 |
| **강제력** | Low (놓침 가능) | Low | **High** | C 승 |

**Negative Evidence:**
- [R1] **AOP 복구 로직 실패:** 각 도메인별 다른 복구 정책을 단일 @Around로 구현 불가 (POC 2025-11-10)
- [R2] **표준화 실패:** Code Review에서 15건의 try-catch 패턴 불일치 발견 (2025-11-12)

## 결정 (Decision)

**LogicExecutor 템플릿과 ExecutionPipeline 기반 Policy 체인을 도입합니다.**

### Code Evidence

**Evidence ID: [C1]** - LogicExecutor 인터페이스
```java
// src/main/java/maple/expectation/global/executor/LogicExecutor.java
public interface LogicExecutor {
    // 패턴 1: 기본 실행
    <T> T execute(ThrowingSupplier<T> task, TaskContext context);

    // 패턴 2: void 작업
    void executeVoid(ThrowingRunnable task, TaskContext context);

    // 패턴 3: 예외 시 기본값 반환
    <T> T executeOrDefault(ThrowingSupplier<T> task, T defaultValue, TaskContext context);

    // 패턴 4: 예외 시 복구 로직
    <T> T executeOrCatch(ThrowingSupplier<T> task, Function<Exception, T> recovery, TaskContext context);

    // 패턴 5: finally 보장
    <T> T executeWithFinally(ThrowingSupplier<T> task, Runnable finallyBlock, TaskContext context);

    // 패턴 6: 예외 변환
    <T> T executeWithTranslation(ThrowingSupplier<T> task, ExceptionTranslator translator, TaskContext context);

    // 패턴 7: Checked + Handler
    <T> T executeCheckedWithHandler(ThrowingSupplier<T> task, Consumer<Exception> handler, TaskContext context);

    // 패턴 8: Fallback
    <T> T executeWithFallback(ThrowingSupplier<T> task, Supplier<T> fallback, TaskContext context);
}
```

**Evidence ID: [C2]** - TaskContext
```java
// src/main/java/maple/expectation/global/executor/TaskContext.java
public record TaskContext(
    String component,    // 메트릭 태그 (고정) - 예: "NexonApi"
    String operation,    // 메트릭 태그 (고정) - 예: "FetchEquipment"
    String dynamicValue  // 로그에만 기록 (메트릭 제외) - 예: "ocid=abc123"
) {
    public static TaskContext of(String component, String operation, String dynamicValue) {
        return new TaskContext(component, operation, dynamicValue);
    }
}
```

**Evidence ID: [C3]** - ExecutionPipeline
```java
// src/main/java/maple/expectation/global/executor/policy/ExecutionPipeline.java
public class ExecutionPipeline {
    private final List<ExecutionPolicy> beforePolicies = new ArrayList<>();
    private final List<ExecutionPolicy> afterPolicies = new ArrayList<>();

    public <T> T execute(ThrowingSupplier<T> task, TaskContext context) {
        // 1. BEFORE (등록 순서)
        beforePolicies.forEach(p -> p.before(context));

        try {
            // 2. TASK 실행
            T result = task.get();
            onSuccessPolicies.forEach(p -> p.onSuccess(result, context));
            return result;

        } catch (Exception e) {
            onFailurePolicies.forEach(p -> p.onFailure(e, context));
            throw e;

        } finally {
            // 3. AFTER (역순 LIFO)
            Lists.reverse(afterPolicies).forEach(p -> p.after(context));
        }
    }
}
```

### LogicExecutor 8가지 실행 패턴

| 패턴 | 메서드 | 용도 |
|:---:|--------|------|
| 1 | `execute(task, context)` | 기본 실행, 예외 시 로그 후 전파 |
| 2 | `executeVoid(task, context)` | void 작업 실행 |
| 3 | `executeOrDefault(task, default, context)` | 예외 시 기본값 반환 |
| 4 | `executeOrCatch(task, recovery, context)` | 예외 시 복구 로직 실행 |
| 5 | `executeWithFinally(task, finallyBlock, context)` | 리소스 해제 보장 |
| 6 | `executeWithTranslation(task, translator, context)` | 기술 예외 → 도메인 예외 변환 |
| 7 | `executeCheckedWithHandler(task, handler, context)` | Checked 예외 + 복구 |
| 8 | `executeWithFallback(task, fallback, context)` | Fallback 패턴 |

### TaskContext 기반 메트릭 카디널리티 제어
```java
// maple.expectation.global.executor.TaskContext
public record TaskContext(
    String component,    // 메트릭 태그 (고정)
    String operation,    // 메트릭 태그 (고정)
    String dynamicValue  // 로그에만 기록 (메트릭 제외)
) {
    public static TaskContext of(String component, String operation, String dynamicValue) {
        return new TaskContext(component, operation, dynamicValue);
    }
}
```

### ExecutionPipeline 4단계 라이프사이클
```
1. BEFORE (lifecycle 훅) - 정책 순서대로
2. TASK 실행
3. ON_SUCCESS / ON_FAILURE (observability 훅)
4. AFTER (lifecycle 훅) - 역순 LIFO
```

### 핵심 보장 (PRD v4 준수)
```java
// maple.expectation.global.executor.policy.ExecutionPipeline
- elapsedNanos는 task.get() 구간만 측정 (정책 시간 제외)
- BEFORE는 등록 순서, AFTER는 역순(LIFO)
- before() 성공한 정책만 after() 호출 (entered pairing)
- Error는 최우선 전파 대상
- ThreadLocal depth로 재진입 폭주 fail-fast (MAX_NESTING_DEPTH=32)
```

### 사용 예시
```java
// Bad (Legacy)
try {
    return repository.findById(id);
} catch (Exception e) {
    log.error("Error", e);
    return null;
}

// Good (Modern)
return executor.executeOrDefault(
    () -> repository.findById(id),
    null,
    TaskContext.of("Domain", "FindById", String.valueOf(id))
);
```

## 결과 (Consequences)

### 개선 효과

| 지표 | Before | After | Evidence ID |
|------|--------|-------|-------------|
| 예외 처리 일관성 | 개인 스타일 | **100% 표준화** | [E1] |
| 로깅 누락 | 빈번 (~5건/주) | **0건** | [E2] |
| 메트릭 카디널리티 | 폭발 (> 10,000) | **제어됨** | [E3] |
| 코드 가독성 | try-catch 중첩 | **선언적** | [E4] |
| RuntimeException 래핑 | 난립 | **존재하지 않음** | [E5] |

### Evidence IDs

| ID | 타입 | 설명 | 검증 방법 |
|----|------|------|-----------|
| [E1] | Code Review | service/ 패키지 try-catch 0건 | `grep -r "try {" src/main/java/maple/expectation/service/` |
| [E2] | 로그 분석 | TaskContext 누락 0건 | 로그 시스템 쿼리 |
| [E3] | Prometheus | 메트릭 태그 조합 < 100 | `count by (__name__)` |
| [E4] | PR 리뷰 | 람다 중첩 3줄 이하 | PR #266 |
| [E5] | 정적 분석 | RuntimeException 래핑 0건 | SonarQube |
| [C1] | 코드 증거 | LogicExecutor 8가지 패턴 | 인터페이스 소스 |
| [C2] | 코드 증거 | TaskContext Record | 소스 라인 73-81 |
| [C3] | 코드 증거 | ExecutionPipeline LIFO | 소스 라인 85-110 |
| [P1] | 부하테스트 | RPS 719, 0% Error | #266 리포트 |
| [P2] | 안정성 | 장애 시 Fallback 동작 | Chaos Test |

---

## 재현성 및 검증

### try-catch 존재 검증

```bash
# service/ 패키지에서 try-catch 블록 검색
grep -r "try {" src/main/java/maple/expectation/service/ | wc -l
# Expected: 0 (LogicExecutor 외)

# scheduler/ 패키지도 마찬가지
grep -r "try {" src/main/java/maple/expectation/scheduler/ | wc -l
# Expected: 0
```

### 메트릭 카디널리티 확인

```bash
# Prometheus 메트릭 태그 조합 수
curl -s 'http://localhost:9090/api/v1/label/__name__/values' | jq '.[]'
# Expected: < 100 unique metric names
```

### 부하테스트 재현

```bash
# Load Test #266 재현
./gradlew bootRun
wrk -t12 -c200 -d60s http://localhost:8080/api/characters/test/expectation

# 메트릭 확인
curl -s http://localhost:8080/actuator/metrics | jq '.names[] | select(. | contains("executor"))'
```

---

## 관련 문서

### 연결된 ADR
- **모든 ADR** - LogicExecutor는 핵심 패턴으로 전체 적용

### 코드 참조
- **인터페이스:** `src/main/java/maple/expectation/global/executor/LogicExecutor.java`
- **구현:** `src/main/java/maple/expectation/global/executor/DefaultLogicExecutor.java`
- **TaskContext:** `src/main/java/maple/expectation/global/executor/TaskContext.java`
- **Pipeline:** `src/main/java/maple/expectation/global/executor/policy/ExecutionPipeline.java`

### 가이드
- **CLAUDE.md 섹션 12:** Zero Try-Catch Policy
- **CLAUDE.md 섹션 15:** Lambda Hell 방지
