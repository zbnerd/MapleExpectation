# ADR-035: Multi-Module Migration Completion

**Status:** Accepted

**Date:** 2025-02-13

## Context

**Issue:** #282 - Multi-Module Refactoring to Resolve Circular Dependencies

### Problem Statement
The monolithic structure exhibited circular dependencies between business logic and infrastructure concerns, creating several critical issues:

1. **Circular Dependencies:** Global error handling components created tight coupling between modules
2. **Testability Challenges:** Infrastructure dependencies made unit testing difficult
3. **Scale-out Barriers:** Stateful components (static fields, direct cache access) prevented horizontal scaling
4. **Code Organization:** 53 global error files scattered across the codebase lacked clear ownership
5. **Maintainability:** Large files (some 300+ lines) mixed concerns and violated Single Responsibility Principle

### Related Decisions
- **ADR-014:** Multi-module cross-cutting concerns separation design
- **ADR-034:** Stateless alert system migration (preceding refactoring)

## Decision

### Module Structure
Adopt a layered multi-module architecture following Domain-Driven Design principles:

```
maple-expectation/
├── module-common/           # Shared utilities, constants, base classes
├── module-core/             # Domain logic, business rules (DIP interfaces)
├── module-infra/            # Infrastructure implementations (Redis, DB, external APIs)
├── module-app/              # Application layer (Facades, services, controllers)
└── module-chaos-test/       # Chaos engineering, load testing, nightmare scenarios
```

### Key Changes Implemented

#### 1. Global Error Package Relocation (53 files)
**Before:** Scattered across `global.error/` and various packages
**After:** Consolidated into `maple.expectation.error.*` with clear structure:

```
maple.expectation.error/
├── annotation/              # Custom annotations (@CircuitBreakerIgnoreMarker, etc.)
├── challenge/               # Challenge-related errors
├── client/                  # Client API errors
├── code/                    # ErrorCode enum definitions
├── core/                    # Base exception classes (ClientBaseException, ServerBaseException)
├── exception/               # Specific exception implementations
└── handler/                 # GlobalExceptionHandler
```

**Impact:** Clear ownership, improved discoverability, eliminated circular dependencies

#### 2. Dependency Inversion (DIP) Interfaces
Created abstraction interfaces in `module-core` to decouple business logic from infrastructure:

```java
// Core abstraction (module-core)
public interface CacheStrategy {
    <T> Optional<T> get(String key, Class<T> type);
    void put(String key, Object value, Duration ttl);
}

// Infrastructure implementation (module-infra)
@Component
public class RedisCacheStrategy implements CacheStrategy {
    // Redis-specific implementation
}
```

**Benefits:**
- Business logic depends on abstractions, not concrete implementations
- Easy to swap infrastructure (Redis → Caffeine → Memcached)
- Testable with mock implementations

#### 3. Stateless Design Applied
Removed stateful components to enable scale-out:

| Component | Before (Stateful) | After (Stateless) |
|-----------|-------------------|-------------------|
| Caffeine Cache | Static fields | Spring Bean with @Scope |
| Alert Channel | Static lists | Database-backed outbox |
| Configuration | volatile variables | Immutable config objects |
| Worker State | Instance fields | Redis-based distributed state |

**Code Example:**
```java
// Bad (Stateful - prevents scale-out)
public class AlertChannelRegistry {
    private static volatile List<AlertChannel> channels = new ArrayList<>();

    public static void register(AlertChannel channel) {
        channels.add(channel);  // Instance-local state
    }
}

// Good (Stateless - scale-out ready)
@Component
public class AlertChannelService {
    private final AlertChannelRepository repository;  // DB-backed
    private final CacheStrategy cache;                // Distributed cache

    public List<AlertChannel> getActiveChannels() {
        return cache.get("active:channels", AlertChannel.class)
            .orElseGet(() -> repository.findAllActive());
    }
}
```

#### 4. LogicExecutor Pattern Applied
Applied LogicExecutor to 4 critical infrastructure files to eliminate try-catch anti-pattern:

1. `RedisConfig.java` - Cache initialization
2. `AsyncConfiguration.java` - Thread pool setup
3. `SecurityConfig.java` - Filter chain configuration
4. `ChaosTestScenario.java` - Test orchestration

**Pattern:**
```java
// Before (try-catch hell)
try {
    RedisClient client = redisClientFactory.create();
    return client.connect();
} catch (RedisConnectionException e) {
    log.error("Redis connection failed", e);
    throw new ServerException(ErrorCode.REDIS_CONNECTION_FAILED, e);
}

// After (LogicExecutor)
return executor.executeWithTranslation(
    () -> redisClientFactory.create().connect(),
    e -> new ServerException(ErrorCode.REDIS_CONNECTION_FAILED, e),
    TaskContext.of("Redis", "Connect")
);
```

#### 5. Large File Splitting
Split 3 large files to improve maintainability:

| File | Before | After | Reduction |
|------|--------|-------|-----------|
| `GlobalExceptionHandler.java` | 342 lines | 198 lines | -42% |
| `AlertService.java` | 287 lines | 156 lines | -46% |
| `CacheConfiguration.java` | 114 lines | 89 lines | -22% |
| **Total** | **743 lines** | **443 lines** | **-40%** |

**Split Strategy:**
- Extract helper methods to private static classes
- Separate validation logic into dedicated validators
- Move error response building to response builders

### Migration Strategy
1. **Phase 1:** Create module structure and move packages (Issue #282)
2. **Phase 2:** Apply DIP interfaces and resolve circular dependencies
3. **Phase 3:** Refactor to stateless design (aligns with ADR-034)
4. **Phase 4:** Apply LogicExecutor pattern
5. **Phase 5:** Split large files and clean up

## Consequences

### Positive Outcomes

1. **Clean Architecture:**
   - Clear separation of concerns (Core → Infra → App)
   - Dependency Inversion Principle enforced
   - Open/Closed Principle (open for extension, closed for modification)

2. **Testability:**
   - Unit tests can mock infrastructure interfaces
   - No Spring context required for core logic tests
   - Faster test execution (reduced Spring startup overhead)

3. **Scale-out Ready:**
   - Stateless design enables horizontal scaling
   - Distributed cache (Redis) replaces local state
   - Database-backed outbox for async operations

4. **Maintainability:**
   - Clear module boundaries prevent leakage
   - Reduced file sizes improve code navigation
   - Consistent error package structure

5. **Code Quality:**
   - LogicExecutor eliminates try-catch anti-pattern
   - Reduced code duplication (40% reduction in large files)
   - Better error messages with structured logging

### Negative Trade-offs

1. **Increased Complexity:**
   - More packages and modules to navigate
   - Learning curve for DIP pattern
   - Initial setup overhead (abstraction interfaces)

2. **Indirection:**
   - Additional interface layer adds indirection
   - Slightly longer call chains (core interface → infra impl)
   - More files to maintain overall

3. **Migration Effort:**
   - Required careful refactoring of 53 error files
   - Breaking changes to internal APIs
   - Coordination across team for large file splits

### Mitigation Strategies

- **Module Documentation:** Clear package-info.java files explain ownership
- **Dependency Rules:** Gradle module dependencies enforce architectural rules
- **Code Reviews:** Strict review process to prevent architectural drift
- **Tooling:** ArchUnit tests to enforce module boundaries at build time

## References

- **ADR-014:** Multi-Module Cross-Cutting Concerns (original design)
- **ADR-034:** Stateless Alert System (preceding migration)
- **Issue #282:** Multi-Module Refactoring Implementation
- **Issue #283:** Scale-out Roadmap (next steps)
- **docs/03_Technical_Guides/service-modules.md:** Module dependency graph
- **docs/00_Start_Here/ROADMAP.md:** Phase 7 completion criteria

---

**Decision Maker:** Development Team

**Reviewers:** Architecture Team

**Next Steps:**
1. Monitor module dependency violations with ArchUnit
2. Continue refactoring remaining stateful components (Issue #283)
3. Update onboarding documentation for new module structure
4. Consider module-specific deployment in future phases
