# Nightmare 11: Lock Fallback Avalanche

> **담당 에이전트**: 🔴 Red (장애주입) & 🟢 Green (성능)
> **난이도**: P1 (High)
> **예상 결과**: PASS

---

## 0. 최신 테스트 결과 (2025-01-20)

### ✅ PASS (3/3 테스트 성공)

| 테스트 메서드 | 결과 | 설명 |
|-------------|------|------|
| `shouldCollectHikariMetrics()` | ✅ PASS | HikariCP 메트릭 수집 확인 |
| `shouldExecuteQueryWhileHoldingLock()` | ✅ PASS | 락 보유 중 쿼리 실행 가능 |
| `shouldNotExhaustPool_withConcurrentFallback()` | ✅ PASS | 동시 Fallback 시 Pool 고갈 방지 |

### 🟢 성공 원인
- **Semaphore 기반 동시성 제한**: 최대 5개 동시 Fallback 요청
- **HikariCP 메트릭 모니터링**: 실시간 Connection Pool 상태 감시
- **빠른 실패**: tryAcquire 타임아웃으로 무한 대기 방지

---

## 1. 테스트 전략 (🟡 Yellow's Plan)

### 목적
Redis 장애 시 모든 락 요청이 MySQL Named Lock으로 Fallback될 때
HikariCP Connection Pool이 고갈되는 현상을 검증한다.

### 검증 포인트
- [ ] MySQL Named Lock의 Connection 점유 특성
- [ ] Connection Pool 고갈 여부
- [ ] HikariCP 메트릭 수집

### 성공 기준
- Connection timeout 0건
- Pool 고갈로 인한 실패 없음

---

## 2. 장애 주입 (🔴 Red's Attack)

### MySQL Named Lock의 특성
```
MySQL GET_LOCK 특성:
- 각 락이 별도 Connection 점유
- 락 해제까지 Connection 반환 불가
- 세션 종료 시 자동 해제
```

### 공격 벡터
```
[Redis Down] → [30개 동시 락 요청] → [각각 Connection 점유]
                        ↓
            Pool Size(10) < 요청(30)
                        ↓
              Connection Timeout!
```

---

## 3. 그라파나 대시보드 (🟢 Green's Analysis)

### 프로메테우스 쿼리
```promql
# HikariCP 상태
hikaricp_connections_active{pool="HikariPool-1"}
hikaricp_connections_idle{pool="HikariPool-1"}
hikaricp_connections_pending{pool="HikariPool-1"}
hikaricp_connections_timeout_total{pool="HikariPool-1"}

# Connection 대기 시간
hikaricp_connections_acquire_seconds_sum / hikaricp_connections_acquire_seconds_count
```

---

## 4. 해결 방안

### Bulkhead Pattern 적용
```java
@Configuration
public class LockPoolConfig {
    // Named Lock 전용 Connection Pool
    @Bean
    @Qualifier("lockDataSource")
    public DataSource lockDataSource() {
        HikariConfig config = new HikariConfig();
        config.setPoolName("LockPool");
        config.setMaximumPoolSize(5);  // 락 전용 제한된 풀
        config.setConnectionTimeout(1000);  // 빠른 실패
        return new HikariDataSource(config);
    }
}
```

### Semaphore 기반 동시성 제한
```java
private final Semaphore fallbackSemaphore = new Semaphore(5);

public <T> T executeWithMysqlFallback(String key, Supplier<T> task) {
    if (!fallbackSemaphore.tryAcquire(100, TimeUnit.MILLISECONDS)) {
        throw new DistributedLockException("Fallback capacity exceeded");
    }
    try {
        return mysqlLockStrategy.executeWithLock(key, task);
    } finally {
        fallbackSemaphore.release();
    }
}
```

---

## 5. 관련 CS 원리

### Connection Pool Exhaustion
동시 요청이 Pool 크기를 초과할 때 발생.
각 요청이 Connection을 장시간 점유하면 악화됨.

### Bulkhead Pattern
선박의 격벽처럼 자원을 분리하여 장애 격리.

```
Before Bulkhead:
[Main Pool: 10] ← 일반 쿼리 + 락 요청 혼재

After Bulkhead:
[Main Pool: 10] ← 일반 쿼리만
[Lock Pool: 5]  ← 락 요청 전용
```

---

## 6. 최종 판정 (🟡 Yellow's Verdict)

### 결과: **PASS**

MySQL Named Lock이 별도 Connection을 점유하지만,
**HikariCP 메트릭 모니터링** 및 **Semaphore 기반 동시성 제한**으로
Connection Pool 고갈을 방지함을 확인.

### 기술적 인사이트
- **Connection 점유 특성**: Named Lock은 RELEASE_LOCK까지 Connection 유지
- **Pool Isolation**: 락 전용 Connection Pool 분리 가능 (Bulkhead)
- **동시성 제한**: Semaphore로 최대 동시 Fallback 요청 수 제한
- **빠른 실패**: tryAcquire 타임아웃으로 무한 대기 방지

### 권장 유지 사항
1. **HikariCP 메트릭 모니터링**: `hikaricp_connections_active` 알림 설정
2. **Fallback Semaphore 유지**: 현재 5개 동시 요청 제한 적절
3. **Connection Timeout 설정**: 1000ms 빠른 실패 유지
4. **Pool 크기 여유**: maxPoolSize > 예상 동시 락 요청 수

---

*Generated by 5-Agent Council*
