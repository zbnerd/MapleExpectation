# ADR-003: 다계층 캐시 및 SingleFlight 패턴 도입

## 상태
Accepted

## 문서 무결성 체크리스트 (Documentation Integrity Checklist)

### 1. 기본 정보
| # | 검증 항목 | 상태 | 비고 |
|---|-----------|------|------|
| 1 | 의사결정 날짜 | ✅ | 2025-12-20 (PR #160) |
| 2 | 결정자 | ✅ | Blue Agent (Architecture) |
| 3 | 관련 Issue/PR | ✅ | #160 SingleFlight Follower Timeout Fix |
| 4 | 상태 명확함 | ✅ | Accepted & Implemented |
| 5 | 최종 업데이트 | ✅ | 2026-02-05 |

### 2. 맥락 및 문제 정의
| # | 검증 항목 | 상태 | 비고 |
|---|-----------|------|------|
| 6 | 비즈니스 문제 | ✅ | Cache Stampede로 DB/외부 API 과부하 |
| 7 | 기술적 문제 | ✅ | TTL 만료 시 100 동시 요청 → DB 100회 호출 |
| 8 | 성능 수치 | ✅ | p99 2,340ms → 180ms |
| 9 | 영향도 | ✅ | Thread Pool 고갈, 응답 지연 |
| 10 | 선행 조건 | ✅ | Caffeine, Redis, Redisson |

### 3. 대안 분석
| # | 검증 항목 | 상태 | 비고 |
|---|-----------|------|------|
| 11 | 최소 3개 대안 | ✅ | TTL 랜덤화, synchronized, TieredCache+SF |
| 12 | 장단점 비교 | ✅ | 표로 정리 |
| 13 | 거절 근거 | ✅ | "부분적 해결", "확장성 부족" |
| 14 | 채택 근거 | ✅ | 중복 요청 완벽 제거, L1 속도 향상 |
| 15 | 트레이드오프 | ✅ | 구현 복잡도 vs 성능 |

### 4. 결정 및 증거
| # | 검증 항목 | 상태 | 비고 |
|---|-----------|------|------|
| 16 | 구현 결정 | ✅ | L1(Caffeine)+L2(Redis)+SingleFlight |
| 17 | Evidence ID | ✅ | [E1], [C1], [P1] 참조 |
| 18 | 코드 참조 | ✅ | 실제 클래스 경로 확인 완료 |
| 19 | 성능 수치 | ✅ | Before/After 표 |
| 20 | 부작용 | ✅ | 구현 복잡도, Follower timeout |

### 5. 실행 및 검증
| # | 검증 항목 | 상태 | 비고 |
|---|-----------|------|------|
| 21 | 구현 클래스 | ✅ | `TieredCacheManager`, `SingleFlightExecutor` |
| 22 | 재현성 명령어 | ✅ | Chaos Test N01, N05 |
| 23 | 롤백 계획 | ✅ | Spring Cache @Cacheable로 롤백 |
| 24 | 모니터링 | ✅ | Cache Hit/Miss, SingleFlight metrics |
| 25 | 테스트 커버리지 | ✅ | `TieredCacheManagerTest`, N01/N05 |

### 6. 유지보수
| # | 검증 항목 | 상태 | 비고 |
|---|-----------|------|------|
| 26 | 관련 ADR | ✅ | ADR-007 (AOP 통합) |
| 27 | 만료일 | ✅ | 없음 (장기 유효) |
| 28 | 재검토 트리거 | ✅ | Cache Hit Rate < 80% |
| 29 | 버전 호환성 | ✅ | Caffeine 3.x, Redisson 3.27+ |
| 30 | 의존성 변경 | ✅ | Spring Cache 2.x |

---

## Fail If Wrong (ADR 무효화 조건)

이 ADR은 다음 조건에서 **즉시 무효화**됩니다:

1. **[F1]** Cache Stampede 발생 시 SingleFlight가 동작하지 않음 (Chaos Test N01 실패)
2. **[F2]** L1 캐시 메모리 누수로 OOM 발생
3. **[F3]** Follower timeout으로 병목 발생 (p99 > 500ms)
4. **[F4]** Redis Cluster 환경에서 Lua Script Hash Tag 미사용으로 Cross-slot 실패

---

## Terminology (용어 정의)

| 용어 | 정의 |
|------|------|
| **Cache Stampede** | 캐시 만료 시점에 다수 요청이 동시에 DB/외부 API 호출하는 현상 (Thundering Herd) |
| **Tiered Cache** | L1(로컬) + L2(분산) 다계층 구조. L1 미스 시 L2 조회, L2 미스 시 DataSource. |
| **SingleFlight** | 동일 key에 대한 동시 요청을 병합하여 단 한 번의 실행만 수행하는 패턴. |
| **Leader/Follower** | SingleFlight에서 첫 요청자(Leader)는 실제 작업 수행, 나머지(Follower)는 결과 대기. |
| **Follower Timeout** | Leader 작업 지연 시 Follower가 독립적으로 타임아웃 처리하는 메커니즘. |

---

## 맥락 (Context)

### 문제 정의

캐시 만료 시점에 동시 요청이 몰리면 **Cache Stampede**가 발생합니다.

**관찰된 문제:**
- 인기 캐릭터 조회 캐시 TTL 만료 직후 동시 요청 폭주 [E1]
- 결과: DB/외부 API에 동시 요청 → 과부하 [E2]
- Thread Pool 고갈 및 응답 지연 (p99 2,340ms) [E3]

**성능 수치:**
```
Scenario: 캐시 만료 + 100 동시 요청

Before (SingleFlight 없음):
  - DB 호출: 100회
  - p99 Latency: 2,340ms
  - Thread Pool: 고갈 발생

After (TieredCache + SingleFlight):
  - DB 호출: 1회
  - p99 Latency: 180ms (-92%)
  - Thread Pool: 안정
```

## 검토한 대안 (Options Considered)

### 옵션 A: TTL 랜덤화
```java
Duration ttl = Duration.ofMinutes(5 + random.nextInt(2));
```
- **장점:** 만료 시점 분산, 구현 간단
- **단점:** 여전히 동시 만료 가능 (확률적 감소만)
- **거절 근거:** [R1] Chaos Test N01 결과: 100요청 중 평균 30회가 여전히 동시 만료
- **결론:** 부분적 해결 (기각)

### 옵션 B: Cache Aside + synchronized
```java
synchronized (key.intern()) {
    if (cache.get(key) == null) {
        cache.put(key, fetchFromDb());
    }
}
```
- **장점:** 중복 조회 방지, JVM 레벨 locking
- **단점:** 분산 환경에서 동작 안 함 (`String.intern()`은 JVM 로컬)
- **거절 근거:** [R2] Scale-out 환경(서버 2대)에서 각 서버가 독립적으로 DB 호출
- **결론:** 확장성 부족 (기각)

### 옵션 C: TieredCache + SingleFlight + Redisson 분산락
- **장점:**
  - 중복 요청 완벽 제거 (Leader/Follower 패턴)
  - L1(Caffeine)으로 추가 속도 향상 (< 5ms)
  - 분산 환경 지원 (Redisson Lua Script)
- **단점:** 구현 복잡도 증가
- **채택 근거:** [C1] Chaos Test N01/N05 통과, p99 2,340ms → 180ms 개선
- **결론:** 채택

### Trade-off Analysis

| 평가 기준 | 옵션 A (TTL 랜덤) | 옵션 B (synchronized) | 옵션 C (Tiered+SF) | 비고 |
|-----------|-------------------|----------------------|-------------------|------|
| **Cache Stampede 방지** | 30% 감소 | 100% (단일 JVM) | **100% (분산)** | C 승 |
| **응답 속도 (L1 HIT)** | 20ms | 20ms | **< 5ms** | C 승 |
| **분산 환경 지원** | Yes | No | **Yes** | A/C 승 |
| **구현 복잡도** | Low | Low | Medium | A/B 승 |
| **확장성** | Medium | Low | **High** | C 승 |
| **Thread Pool 안정성** | 개선 없음 | 개선 없음 | **향상** | C 승 |

**Negative Evidence:**
- [R1] **TTL 랜덤화 실패:** Chaos Test N01에서 100요청 중 30회가 여전히 DB 호출 (테스트: 2025-12-18)
- [R2] **synchronized 분산 실패:** Docker Compose로 서버 2대 구성 시 각각 독립 DB 호출 확인 (테스트: 2025-12-19)

## 결정 (Decision)

**L1(Caffeine) + L2(Redis) 다계층 캐시와 SingleFlight를 조합합니다.**

### Code Evidence (실제 구현)

**Evidence ID: [C1]** - TieredCacheManager
```java
// src/main/java/maple/expectation/global/cache/TieredCacheManager.java
@RequiredArgsConstructor
public class TieredCacheManager extends AbstractCacheManager {
    private final CacheManager l1Manager;      // Caffeine
    private final CacheManager l2Manager;      // Redis
    private final LogicExecutor executor;
    private final RedissonClient redissonClient;
    private final MeterRegistry meterRegistry;

    // 인스턴스 풀링으로 O(1) 조회
    private final ConcurrentMap<String, Cache> cachePool = new ConcurrentHashMap<>();

    @Override
    public Cache getCache(String name) {
        return cachePool.computeIfAbsent(name, this::createTieredCache);
    }
}
```

**Evidence ID: [C2]** - SingleFlightExecutor
```java
// src/main/java/maple/expectation/global/concurrency/SingleFlightExecutor.java
public class SingleFlightExecutor<T> {
    private final int followerTimeoutSeconds;
    private final Executor executor;
    private final ConcurrentHashMap<String, InFlightEntry<T>> inFlight = new ConcurrentHashMap<>();

    public CompletableFuture<T> executeAsync(
            String key,
            Supplier<CompletableFuture<T>> asyncSupplier) {

        InFlightEntry<T> existing = inFlight.putIfAbsent(key, newEntry);

        if (existing == null) {
            return executeAsLeader(key, newEntry, asyncSupplier);  // 실제 계산
        }
        return executeAsFollower(key, existing.promise());  // Leader 결과 대기
    }

    // P1 Fix: 각 follower에게 독립적인 Future 생성
    private CompletableFuture<T> executeAsFollower(String key, CompletableFuture<T> leaderFuture) {
        CompletableFuture<T> isolatedFuture = new CompletableFuture<>();
        leaderFuture.whenComplete((result, error) -> {
            if (error != null) isolatedFuture.completeExceptionally(error);
            else isolatedFuture.complete(result);
        });

        return isolatedFuture
                .orTimeout(followerTimeoutSeconds, TimeUnit.SECONDS)
                .exceptionallyCompose(e -> handleFollowerException(key, e));
    }
}
```

### 실제 캐시 설정 (CacheConfig.java)

| Cache Name | L1 TTL | L1 Max | L2 TTL | 용도 |
|------------|--------|--------|--------|------|
| `equipment` | 5 min | 5,000 | 10 min | Nexon API 장비 데이터 [C3] |
| `cubeTrials` | 10 min | 5,000 | 20 min | Cube 확률 계산 |
| `ocidCache` | 30 min | 5,000 | 60 min | OCID 매핑 |
| `expectationV4` | 60 min | 5,000 | 60 min | 기대값 계산 결과 |

### 캐시 조회 흐름
```
[Request]
    ↓
[L1 Cache - Caffeine]  ← HIT: < 5ms
    ↓ miss
[L2 Cache - Redis]     ← HIT: < 20ms
    ↓ miss
[SingleFlight]         ← 동일 key 요청 병합
    ↓
[External API / DB]
```

### 실제 캐시 설정 (CacheConfig.java)
| Cache Name | L1 TTL | L1 Max | L2 TTL | 용도 |
|------------|--------|--------|--------|------|
| `equipment` | 5 min | 5,000 | 10 min | Nexon API 장비 데이터 |
| `cubeTrials` | 10 min | 5,000 | 20 min | Cube 확률 계산 |
| `ocidCache` | 30 min | 5,000 | 60 min | OCID 매핑 |
| `expectationV4` | 60 min | 5,000 | 60 min | 기대값 계산 결과 |

### TieredCacheManager 구현
```java
// maple.expectation.global.cache.TieredCacheManager
@RequiredArgsConstructor
public class TieredCacheManager extends AbstractCacheManager {
    private final CacheManager l1Manager;      // Caffeine
    private final CacheManager l2Manager;      // Redis
    private final LogicExecutor executor;
    private final RedissonClient redissonClient;  // 분산 락용
    private final MeterRegistry meterRegistry;    // 메트릭 수집용

    // 인스턴스 풀링으로 O(1) 조회
    private final ConcurrentMap<String, Cache> cachePool = new ConcurrentHashMap<>();

    @Override
    public Cache getCache(String name) {
        return cachePool.computeIfAbsent(name, this::createTieredCache);
    }
}
```

### SingleFlightExecutor 구현
```java
// maple.expectation.global.concurrency.SingleFlightExecutor
public class SingleFlightExecutor<T> {
    private final int followerTimeoutSeconds;
    private final Executor executor;
    private final Function<String, T> timeoutFallback;
    private final ConcurrentHashMap<String, InFlightEntry<T>> inFlight = new ConcurrentHashMap<>();

    public CompletableFuture<T> executeAsync(
            String key,
            Supplier<CompletableFuture<T>> asyncSupplier) {

        InFlightEntry<T> existing = inFlight.putIfAbsent(key, newEntry);

        if (existing == null) {
            return executeAsLeader(key, newEntry, asyncSupplier);  // 실제 계산
        }
        return executeAsFollower(key, existing.promise());  // Leader 결과 대기
    }
}
```

### Follower 타임아웃 격리 (P1 Fix)
```java
// PR #160: 각 follower에게 독립적인 Future 생성 (공유 promise 보호)
private CompletableFuture<T> executeAsFollower(String key, CompletableFuture<T> leaderFuture) {
    CompletableFuture<T> isolatedFuture = new CompletableFuture<>();
    leaderFuture.whenComplete((result, error) -> {
        if (error != null) isolatedFuture.completeExceptionally(error);
        else isolatedFuture.complete(result);
    });

    return isolatedFuture
            .orTimeout(followerTimeoutSeconds, TimeUnit.SECONDS)
            .exceptionallyCompose(e -> handleFollowerException(key, e));
}
```

## 결과 (Consequences)

### 성능 개선 (Evidence: [E1], [E2], [E3])

| 시나리오 | Before | After | 개선율 | Evidence ID |
|----------|--------|-------|--------|-------------|
| 캐시 만료 + 100 동시 요청 | DB 100회 | **DB 1회** | **-99%** | [E1] |
| p99 응답시간 | 2,340ms | **180ms** | **-92%** | [E2] |
| DB 부하 | 스파이크 발생 | **안정** | **해결** | [E3] |
| L1 Cache HIT (p50) | N/A | **< 5ms** | **New** | [E4] |

### Evidence IDs (증거 상세)

| ID | 타입 | 설명 | 검증 방법 |
|----|------|------|-----------|
| [E1] | Chaos Test | N01 Thundering Herd: DB 호출 100회 → 1회 | `NexonApiChaosTest` |
| [E2] | Latency | p99 2,340ms → 180ms | Micrometer Timer |
| [E3] | DB 부하 | Connection Pool 안정 | HikariCP metrics |
| [E4] | L1 Cache | Caffeine HIT < 5ms | `TieredCacheManagerTest` |
| [C1] | 코드 증거 | `TieredCacheManager` 구현 | 소스 라인 35-85 |
| [C2] | 코드 증거 | `SingleFlightExecutor` Follower timeout | 소스 라인 97-124 |
| [C3] | 설정 증거 | `CacheConfig` 4개 캐시 설정 | application.yml |

### Negative Evidence (거절 대안 실패)

| ID | 거절 대안 | 실패 증거 |
|----|-----------|-----------|
| [R1] | TTL 랜덤화 | Chaos Test N01: 100요청 중 30회 DB 호출 (2025-12-18) |
| [R2] | synchronized | 서버 2대에서 각각 독립 DB 호출 확인 (2025-12-19) |

---

## 재현성 및 검증

### Chaos Test 실행 명령어

```bash
# N01: Thundering Herd (Cache Stampede)
./gradlew test --tests "maple.expectation.chaos.nightmare.N01ThunderingHerdTest"

# N05: Hot Key (인기 캐릭터 조회)
./gradlew test --tests "maple.expectation.chaos.nightmare.N05HotKeyTest"

# SingleFlight Follower Timeout 테스트
./gradlew test --tests "maple.expectation.global.concurrency.SingleFlightExecutorTest"
```

### 메트릭 확인 (Prometheus)

```promql
# Cache Hit Rate
rate(cache_hits_total[5m]) / (rate(cache_hits_total[5m]) + rate(cache_misses_total[5m]))

# SingleFlight Leader/Follower ratio
rate(singleflight_leader_total[5m]) / rate(singleflight_follower_total[5m])

# DB Connection Pool 사용량
hikaricp_connections_active / hikaricp_connections_max
```

### 코드 검증

```bash
# TieredCacheManager 클래스 확인
grep -r "class TieredCacheManager" src/main/java/

# SingleFlightExecutor 확인
grep -r "class SingleFlightExecutor" src/main/java/

# Follower timeout 로직 확인
grep -A 10 "executeAsFollower" src/main/java/maple/expectation/global/concurrency/SingleFlightExecutor.java
```

---

## 관련 문서

### 연결된 ADR
- **[ADR-007](ADR-007-aop-async-cache-integration.md)** - NexonDataCacheAspect 통합
- **[ADR-004](ADR-004-logicexecutor-policy-pipeline.md)** - LogicExecutor 패턴

### 코드 참조
- **TieredCache:** `src/main/java/maple/expectation/global/cache/TieredCacheManager.java`
- **SingleFlight:** `src/main/java/maple/expectation/global/concurrency/SingleFlightExecutor.java`
- **설정:** `src/main/java/maple/expectation/config/CacheConfig.java`
- **테스트:** `src/test/java/maple/expectation/chaos/nightmare/N01ThunderingHerdTest.java`

### 이슈 및 PR
- **[PR #160](https://github.com/zbnerd/MapleExpectation/pull/160)** - SingleFlight Follower Timeout Fix
- **Chaos Tests:** `docs/01_Chaos_Engineering/06_Nightmare/`
